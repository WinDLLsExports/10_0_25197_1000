                        step(1.0 + Epsilon, colorRgb) * positiveFactor);
            minfloat diffuseAmount, minfloat3 lightColor)
            minfloat specularShine, minfloat specularAmount, minfloat3 lightColor)
            minfloat3 lightColor)
            minfloat3 lightPosition, minfloat diffuseAmount,
            minfloat3 lightPosition, minfloat specularShine, minfloat specularAmount,
        ((colorRgb.g - colorRgb.b) / colorHsl.y) :
        (0.272 * intensity) * color.r
        (0.349 * intensity) * color.r
        (1 - 0.607 * intensity) * color.r
        (2.0 + (colorRgb.b - colorRgb.r) / colorHsl.y) :
        (4.0 + (colorRgb.r - colorRgb.g) / colorHsl.y);
        (flMax == colorRgb.g) ?
        (flMax == colorRgb.r) ?
        );
        * diffuseAmount * lightColor, 1);
        * diffuseAmount * spotLightColor, 1);
        : ((f < 1) ? (0.5 * b / (1 - f)) : 1);
        : 0;
        : b >= f ? 1
        : sum > 1.001 ? 1
        ? ((f > 0) ? (c / f) : 0)
        + (0.168 * intensity) * color.b);
        + (0.189 * intensity) * color.b);
        + (0.534 * intensity) * color.g
        + (0.769 * intensity) * color.g
        + (1 - 0.314 * intensity) * color.g
        + (1 - 0.869 * intensity) * color.b);
        + b.rgb * (1 - f.a));
        + f.rgb * (1 - b.a)
        0.0 :
        color *= destSat;
        color += sourceMaxVector;
        color += sourceMidVector * ((sourceMid - sourceMin) / (sourceMax - sourceMin));
        color = D2DBlendApplySourceLumToDest(color, destSat, D2DBlendGetLuminosity(lumSource));
        color = D2DBlendGetLuminosity(lumFallback).xxx;
        color,
        color[i] = (b[i] >= 1.0) ? 1.0 : (color[i] > 0.0) ? color2[i] : 0.0;
        D2DBlendColorDodgeComponent(uf.b, ub.b));
        D2DBlendColorDodgeComponent(uf.g, ub.g),
        D2DBlendColorDodgeComponent(uf.r, ub.r),
        D2DBlendHardMixComponent(uf.b, ub.b));
        D2DBlendHardMixComponent(uf.g, ub.g),
        D2DBlendHardMixComponent(uf.r, ub.r),
        D2DBlendSafeDivision(uf.b, ub.b));
        D2DBlendSafeDivision(uf.g, ub.g),
        D2DBlendSafeDivision(uf.r, ub.r),
        D2DBlendVividLightComponent(uf.b, ub.b));
        D2DBlendVividLightComponent(uf.g, ub.g),
        D2DBlendVividLightComponent(uf.r, ub.r),
        EncodeReflectanceModelAndTransparentNormal(reflectanceModel, normalHeight));
        float nDotH = max(dot(surfaceNormal, halfVector), 0);
        float3 halfVector = lightVector + eyeVector;
        focus, cosConeAngle, lightColor,
        halfVector = normalize(halfVector);
        lerp(((9 - 18 * uf) * ub + 5.76 * uf - 1.88) * ub,
        lerp(color0, color1, weights.x),
        lerp(color2, color3, weights.x),
        lerp(sourceLum + (((color - sourceLum.xxx) * factor2) / factor1),
        lightVector, exponent, eyeVector) * amount * lightColor;
        output = 0;
        output = pow(nDotH, exponent);
        pixelPosition, lightVector);
        pixelPosition, lightVector, spotLightColor);
        return b / f;
        return b == 0 ? 0 : 1;
        round(ub + (0.359375 - 0.001))), round(uf));
        specularShine, specularAmount, lightColor, minfloat3(0,0,1));
        specularShine, specularAmount, spotLightColor, minfloat3(0,0,1));
        step(0, lumDifference));
        step(factor1, factor2)),
        ub + (sqrt(ub) - ub) * (2 * uf - 1),
        weights.y
    )
    //
    //  - if the lightVector is in the inner cone, we'll get full power (1)
    //  - if the lightVector is in the outer cone, power will fade to 0
    //  - outside of the outer cone, power will be 0
    // (Math from D2D)
    // 0 -> Fully desaturated
    // 1 -> Original color
    // 2 -> Maximum possible value, not necessarily fully saturated
    // and https://www.w3.org/TR/SVG/filters.html#feColorMatrixValuesAttribute
    // Bit 0: a bool to store if this pixel is a fully transparent
    // Bit 1: Reflectance model. Blinn Phong (the default value) = 0, Physically Based Blinn Phong = 1
    // calculating floor(1 - (max - source)), which will result in a unit vector with a value
    // color is our output value:
    // Compute attenuated light color from the position and exponent
    // delay the wrapping until the sampling stage
    // Does not need alpha unpremultiplication
    // else                     return 1 - ((1 - dest) / source)
    // else               return dest + (sqrt(dest) - dest) * (2 * source - g_vectorOneMin16);
    // else             return 1 - 2 * (1 - source) * (1 - dest);
    // Extract the highest values for rgb's that are < 0 or > 1
    // Flip the Y axis, because the standard normal map tools assuming the Y
    // H
    // if (dest < 0.5)  return 2 * source * dest;
    // if (dest <= 9/64)   return ((9 * g_vectorOneMin16 - 18 * source) * dest + 5.76 * source - 1.88 * g_vectorOneMin16) * dest;
    // if (source + dest <= 1)  return 0;
    // if (source < 0.5)  return dest * (1 + (1 - dest) * (2 * source - 1))
    // if (source == 1)         return 1;
    // If the signedMod is negative, we must fix it up to wrap it into
    // If we had a tie for max or min, we want to disambiguate. It doesn't matter which value we
    // In D2D, if amount is
    // in texture coordinate is pointing up, but our Y are pointing down.
    // in the box from (0, 0) to (1, 1), and passing by (0.5, 0.5)
    // instructions, so we do the following instead:
    // is reduced much.
    // L
    // lerp is used to simulate if/else conditions.
    // Magic numbers for hashing the coordinates
    // Math from https://www.w3.org/TR/filter-effects/#grayscaleEquivalent
    // Math from https://www.w3.org/TR/filter-effects/#saturateEquivalent
    // Math from https://www.w3.org/TR/filter-effects/#sepiaEquivalent
    // note: it is ok if some colorU channels are zero because those failed quotients will not be chosen below
    // O_A = F_A * (1 - B_A) + B_A
    // O_PRGB = f(F_RGB, B_RGB) * F_A * B_A + F_RGB * (1 - B_A) + B_RGB * (1 - F_A) 
    // of one for the source's max component.
    // out-of-gamut processing
    // pick as the tie breaker, so we use saturate(sourceMaxVector.rgb - sourceMaxVector.gbr),
    // positive space.
    // Premultiply the RGB channels
    // Probability Theory and Mathematical Statistics, August 1998.
    // RGB to luminance factors from D2D
    // S
    // Similar calculation for min:
    // so the alpha channel is not opaque
    // The theroy is from a paper On generating random numbers, with help of y= [(a+x)sin(bx)] mod 1",
    // The weights will be always be between 0 and 0.5. If they are 0, we should
    // Then cut off the light based on the spotlight cone:
    // these two values into vectors, allowing for the comparisons for both to be done in parallel.
    // This accomplishes the following without branching (14 instructions vs. 20):
    // This accomplishes the following without branching:
    // This builds two contiguous polynomials forming an 'S' shape
    // This computes a specular component, meant to be blended atop a diffuse layer,
    // This is just trying to do (sourceMax - sourceMin) > 0 && destSat > 0, but that takes too many
    // This line of code is from https://www.shadertoy.com/view/4dS3Wd. It uses a very high frequency sin
    // to produce a periodic change between pixels. And then take the fractal part as a random number.
    // TODO: Do this up-front on the CPU (MSFT:3579391)
    // use 0,0,1 for the eye vector since this function is used for Image Lighting
    // Use a single componentwise comparison to select per-channel results.
    // use the close pixel, so we put the close pixel in xy.
    // Use this magic number to adjust the frequency of the white noise. When moving slowly, the artifact
    // W.J.J. Rey, 22nd European Meeting of Statisticians and the 7th Vilnius Conference on
    // We can calculate the mid-value vector and value once the min and max vector are known:
    // We can just take the abs of the signedMod, as this mirrors around 0.
    // We follow D2D's way of handling alpha = 0
    // We need to calculate the min and max of the hueSource and satSource. To save instructions, pack
    // We need to figure out which componenet contributed to the max value. We do this by
    // which guarauntees only one component has a 1:
    [unroll]
    {
    }
    color = dest + lumDifference.xxx;
    color = RestrictGamut(color, sourceLum);
    color = UnPremultiply(color);
    color.rgb *= color.a;
    color.rgb = (color.a == 0) ? float3(0, 0, 0) : (color.rgb / color.a);
    color.rgb = (color.rgb < 0.5f) ? lowResult : highResult;
    colorHsl.x = (colorHsl.y == 0.0) ?
    colorHsl.y = flMax - flMin;
    colorHsl.z = dot(colorRgb, g_luminosityWeights);
    const float COORD_SCALING = 0.81f;
    const float Epsilon = 1e-10;
    const minfloat3 vectorOneMin = minfloat3(1, 1, 1);
    else
    float a1 = -a2;
    float a2 = 2 * c2;
    float b1 = s;
    float b2 = 4 - 3 * s;
    float c2 = s - 1;
    float cosDirection = saturate(dot(-lightVector, lightTargetVector));
    float focus, float2 cosConeAngle,
    float luminance = dot(color.rgb, minfloat3(0.2125f, 0.7154f, 0.0721f));
    float result = lerp(lerp(sample00, sample10, factor.x), lerp(sample01, sample11, factor.x), factor.y);
    float s = 1 - (3.0f / 4.0f) * contrast;
    float sample00 = Hash(pixel00Coord);
    float sample01 = Hash(pixel01Coord);
    float sample10 = Hash(pixel10Coord);
    float sample11 = Hash(pixel11Coord);
    float sum = f + b;
    float2 coord = inputCoord * COORD_SCALING * freq + offset;
    float2 dispSelected = saturate(float2(displacement[selectX], displacement[selectY]));
    float2 factor = coord - pixel00Coord;
    float2 invTextureSize = GetInvTextureSizeFromSamplerDataExt(samplerDataExt);
    float2 min = uvBounds.xy;
    float2 pixel00Coord = floor(coord - 0.5f) + 0.5f;
    float2 pixel01Coord = float2(pixel00Coord.x, pixel11Coord.y);
    float2 pixel10Coord = float2(pixel11Coord.x, pixel00Coord.y);
    float2 pixel11Coord = pixel00Coord + 1;
    float2 signedMod = fmod(uv - uvBounds.xy, size * 2);
    float2 signedWeights = uvTexture - uvClosePixel;
    float2 size = uvBounds.zw - uvBounds.xy;
    float2 textureSize = GetTextureSizeFromSamplerDataExt(samplerDataExt);
    float2 uv,
    float2 uvClosePixel = floor(uvTexture) + 0.5;
    float2 uvFarPixel = uvClosePixel + sign(signedWeights);
    float2 uvs,
    float2 uvTexture = uv * textureSize;
    float2 weights;
    float2 wrapped = abs(signedMod);
    float3 lightColor, out float3 pixelPosition,
    float3 lightPosition, float3 lightTargetVector,
    float3 lightVector;
    float3 normal = normalize(normalHeight.xyz * 2 - 1);
    float3 output;
    float3 pixelPosition;
    float3 spotLightColor;
    float4 color0 = tex.Sample(textureSampler, float2(uvs.x, uvsWrapped.y));
    float4 color0 = tex.Sample(textureSampler, float2(uvsWrapped.x, uvs.y));
    float4 color0 = tex.Sample(textureSampler, uvsWrapped.xy);
    float4 color1 = tex.Sample(textureSampler, float2(uvs.x, uvsWrapped.w));
    float4 color1 = tex.Sample(textureSampler, float2(uvsWrapped.z, uvs.y));
    float4 color1 = tex.Sample(textureSampler, uvsWrapped.zy);
    float4 color2 = tex.Sample(textureSampler, uvsWrapped.xw);
    float4 color3 = tex.Sample(textureSampler, uvsWrapped.zw);
    float4 output;
    float4 samplerData,
    float4 samplerDataExt
    float4 samplerDataExt,
    float4 signedMod = fmod(uv - min.xyxy, size.xyxy);
    float4 uvBounds = GetUVBoundsFromSamplerData(samplerData);
    float4 uvs = float4(uvClosePixel, uvFarPixel) * invTextureSize.xyxy;
    float4 uvsWrapped = CalcWrappedUV(uvs, samplerData, samplerDataExt, /*out*/ weights);
    float4 wrapped = lerp(signedMod + size.xyxy, signedMod, step(0, signedMod));
    for (int i = 0; i < 3; i++)
    if ((sourceMax - sourceMin) * destSat > 0)
    if (dot(surfaceNormal, lightVector) > 0)
    if (f == 0)
    int reflectanceModel,
    lightVector = normalize(lightPosition - pixelPosition);
    minfloat ambientAmount, minfloat diffuseAmount, minfloat specularShine, minfloat specularAmount,
    minfloat c = f + 0.5 * (b - 1);
    minfloat destLum = D2DBlendGetLuminosity(dest);
    minfloat destSat = maxSD.y - minSD.y;
    minfloat diffuseAmount, minfloat3 lightColor)
    minfloat factor1 = destSat - destLum;
    minfloat factor2 = 1 - sourceLum;
    minfloat flMax = max(colorRgb.r, max(colorRgb.g, colorRgb.b));
    minfloat flMin = min(colorRgb.r, min(colorRgb.g, colorRgb.b));
    minfloat focus, minfloat2 cosConeAngle,
    minfloat gray = dot(color.rgb, grayFactor);
    minfloat lumDifference = sourceLum - destLum;
    minfloat sourceLum = D2DBlendGetLuminosity(source);
    minfloat sourceMax = maxSD.x;
    minfloat sourceMid = dot(sourceMidVector, hueSource);
    minfloat sourceMin = minSD.x;
    minfloat specularShine, minfloat specularAmount,
    minfloat t = max(max(t3.x, t3.y), t3.z);
    minfloat2 blue = minfloat2(hueSource.b, satSource.b);
    minfloat2 green = minfloat2(hueSource.g, satSource.g);
    minfloat2 maxSD = max(red, max(green, blue));
    minfloat2 minSD = min(red, min(green, blue));
    minfloat2 red = minfloat2(hueSource.r, satSource.r);
    minfloat3 color = D2DBlendApplyHueSatLum(f.rgb, ub.rgb, ub.rgb, ub.rgb);
    minfloat3 color = D2DBlendApplyHueSatLum(ub.rgb, uf.rgb, ub.rgb, ub.rgb);
    minfloat3 color = D2DBlendGetLuminosity(uf) < D2DBlendGetLuminosity(ub) ? uf : ub;
    minfloat3 color = D2DBlendGetLuminosity(uf) > D2DBlendGetLuminosity(ub) ? uf : ub;
    minfloat3 color = dest + lumDifference.xxx;
    minfloat3 color = lerp(2 * ub * uf, 2 * lerp(ub, 1, uf) - 1, round(uf));
    minfloat3 color = lerp(2 * uf * ub, 2 * lerp(uf, 1, ub) - 1, round(ub));
    minfloat3 color = lerp(min(ub, 2 * uf), max(ub, 2 * uf - 1), round(uf));
    minfloat3 color = lerp(ub * (1 + (1 - ub) * (2 * uf - 1)),
    minfloat3 color = max((1 - f.a) * b.rgb + f.rgb, (1 - b.a) * f.rgb + b.rgb);
    minfloat3 color = minfloat3(
    minfloat3 color = minfloat3(0, 0, 0);
    minfloat3 color = saturate(UnPremultiply(b).rgb + 2 * UnPremultiply(f).rgb - 1);
    minfloat3 color = uf + ub - 1;
    minfloat3 color;
    minfloat3 color2 = color / uf;
    minfloat3 colorHsl;
    minfloat3 colorNeutralRGB = luminance.xxx;
    minfloat3 dest = UnPremultiply(b).rgb;
    minfloat3 highResult = color.rgb * (color.rgb * a2 + b2) + c2;
    minfloat3 lightColor)
    minfloat3 lightColor, minfloat3 eyeVector)
    minfloat3 lightPosition, minfloat3 lightTargetVector,
    minfloat3 lightVector)
    minfloat3 lightVector, minfloat exponent, minfloat amount,
    minfloat3 lightVector, minfloat exponent, minfloat3 eyeVector)
    minfloat3 lowResult = color.rgb * (color.rgb * a1 + b1);
    minfloat3 negativeFactor = -colorRgb / (colorNeutralRGB - colorRgb);
    minfloat3 positiveFactor = (1.0 - colorRgb) / (colorNeutralRGB - colorRgb);
    minfloat3 source = UnPremultiply(f).rgb;
    minfloat3 sourceMaxVector = floor(vectorOneMin - (sourceMax.xxx - hueSource));
    minfloat3 sourceMidVector = vectorOneMin - sourceMaxVector - sourceMinVector;
    minfloat3 sourceMinVector = floor(vectorOneMin - (hueSource - sourceMin.xxx));
    minfloat3 t3 = max( (1.0 - step(0, colorRgb)) * negativeFactor, 
    minfloat3 ub = UnPremultiply(b).rgb;
    minfloat3 uf = UnPremultiply(f).rgb;
    minfloat4 result;
    normal.y = -normal.y;
    normalHeight = UnPremultiply(normalHeight);
    out float2 weights
    out float3 lightVector, out float3 spotLightColor)
    out float3 pixelPosition, out float3 lightVector)
    out float4 outputNormalTangentSpace)
    output.a = max(output.r, max(output.g, output.b));
    output.rgb *= output.a;
    output.rgb = CalculateBlinnPhongLitPixelSpecularUnpremultiplied(surfaceNormal,
    outputNormalTangentSpace = float4(GetSurfaceNormal(normalHeight),
    pixelPosition = float3(pixelXY.xy, 0.0f);
    PreparePointVectors(pixelXY, lightPosition,
    PrepareSpotVectors(pixelXY, lightPosition, lightTargetVector,
    result.a = color.a;
    result.b = minfloat(
    result.g = minfloat(
    result.r = minfloat(
    return (1 - dest.a) * src + (1 - src.a) * dest;
    return (1 - dest.a) * src + dest;
    return (1 - dest.a) * src + src.a * dest;
    return (1 - dest.a) * src;
    return (1 - src.a) * dest;
    return (f < 0.5)
    return (f < 1.0) ? (b / (1.0 - f)) : ceil(b);
    return BorderEffectClamp(uv, samplerData);
    return BorderEffectCombine(BorderEffectClamp(uv, samplerData), BorderEffectMirror(uv, samplerData));
    return BorderEffectCombine(BorderEffectMirror(uv, samplerData), BorderEffectClamp(uv, samplerData));
    return BorderEffectMirror(uv, samplerData);
    return CalculateLitPixelSpecular(surfaceNormal, lightVector,
    return clamp(uv, uvBounds.xy, uvBounds.zw);
    return color;
    return colorHsl;
    return D2DBlendBasicRgb(f, b, abs(UnPremultiply(f).rgb - UnPremultiply(b).rgb));
    return D2DBlendBasicRgb(f, b, color);
    return D2DBlendBasicRgb(f, b, saturate(color));
    return D2DBlendBasicRgb(f, b, saturate(UnPremultiply(b).rgb - UnPremultiply(f).rgb));
    return D2DBlendBasicRgb(f, b, saturate(UnPremultiply(f).rgb + UnPremultiply(b).rgb - 1));
    return D2DBlendBasicRgb(f, b, saturate(UnPremultiply(f).rgb + UnPremultiply(b).rgb));
    return D2DBlendBasicRgb(f, b, UnPremultiply(f).rgb * UnPremultiply(b).rgb);
    return D2DBlendLuminosityRgb(b, f);
    return dest.a * src + (1 - src.a) * dest;
    return dest.a * src;
    return dot(g_luminosityWeights, color);
    return f + b - f * b;
    return f.rgb * (1 - b.rgb) + b.rgb;
    return f.rgb + b.rgb - 2 * f.rgb * b.rgb;
    return float2(uvHorizontal.x, uvVertical.y);
    return float4(ambientAmount, diffuseAmount, specularShine, specularAmount);
    return float4(CalculateLitPixelDiffuse(surfaceNormal, lightVector)
    return float4(result.xxx, 1);
    return frac(1e4f * sin(17.0f * p.x + p.y * 0.1f) * (0.1f + abs(sin(p.y * 13.0f + p.x))));
    return lerp(
    return lerp(color0, color1, weights.x);
    return lerp(color0, color1, weights.y);
    return lerp(colorRgb, colorNeutralRGB, max(0, t));
    return lerp(sourceLum + (((color - sourceLum.xxx) * sourceLum) / destLum),
    return max(dot(surfaceNormal, lightVector), 0);
    return min((1 - f.a) * b.rgb + f.rgb, (1 - b.a) * f.rgb + b.rgb);
    return minfloat4(0, 0, 0, luminance);
    return minfloat4(gray, gray, gray, color.a);
    return minfloat4(lerp(gray.rrr, color.rgb, amount), color.a);
    return mul(color, colorMatrix4x4) + colorOffset;
    return normal;
    return normalHeight.w * heightMapScale;
    return output;
    return Premultiply(color);
    return Premultiply(D2DColorMatrixStraight(UnPremultiply(color), colorMatrix4x4, colorOffset));
    return Premultiply(D2DSepiaStraight(UnPremultiply(color), intensity));
    return reflectanceModel * 2 + (any(normalHeight) ? 1 : 0);
    return result;
    return samplerDataExt.zw;
    return saturate(func * f.a * b.a
    return src + (1 - src.a) * dest;
    return src + dest;
    return src.a * dest;
    return src;
    return sum < 0.999 ? 0
    return uv;
    return uvBounds.zw - abs(wrapped - size);
    return uvToDisplace + (dispSelected - 0.5) * scale * GetInvTextureSizeFromSamplerDataExt(samplerDataExt);
    return wrapped + min.xyxy; 
    return WrapUV2(uv, samplerData);
    return WrapUV4(uv.xyxy, samplerData).xy;
    return WrapUV4(uvs, samplerData);
    SamplerState textureSampler,
    sourceMaxVector = saturate(sourceMaxVector - sourceMaxVector.gbr);
    sourceMinVector = saturate(sourceMinVector - sourceMinVector.gbr);
    spotLightColor *= pow(cosDirection, focus);
    spotLightColor *= smoothstep(cosConeAngle.y, cosConeAngle.x, cosDirection);
    spotLightColor = lightColor;
    Texture2D tex,
    weights = abs(signedWeights);
  eb 0x%p 'p';g  -- terminate Process
  eb 0x%p 't';g  -- terminate Thread
  g                    -- Go (continue)
 * pow(
 : packoffset(c
 : register(b0)
 = D2DBlend
 = D2DComposite
 = D2DContrast(
 = D2DDistantDiffuse(
 = D2DDistantSpecular(
 = D2DGrayscale(
 = D2DLuminanceToAlpha(
 = D2DPointDiffuse(
 = D2DPointSpecular(
 = D2DSaturation(
 = D2DSpotDiffuse(
 = D2DSpotSpecular(
 = minfloat4(
 = Premultiply(
 = Premultiply(minfloat4(
 = saturate(
 = SceneLightingParameters(
 = UnPremultiply(
 = WhiteNoise(
 A^_^
 A_A^_
 A_A^A\
 A_A^A\_^
 A_A^A]A\_
 A_A^A]A\_^]
 H3E H3E
 Microsoft Corporation. All rights reserved.
 Microsoft Operations Puerto Rico1
 Microsoft Operations Puerto Rico1&0$
 MR^o
 Operating System
 or regular debugging.
 tDE3
 Windows
!]_0t
!This program cannot be run in DOS mode.
!TkjE
"XkU-
#   define minp(type) MINP_PREFIX##type
#   define minp(type) type
#define COMMON_HLSL
#define D2DLIGHTING_HLSL
#define minfloat minp(float)
#define minfloat2 minp(float2)
#define minfloat2x2 minp(float2x2)
#define minfloat3 minp(float3)
#define minfloat3x2 minp(float3x2)
#define minfloat3x3 minp(float3x3)
#define minfloat4 minp(float4)
#define minfloat4x4 minp(float4x4)
#else
#endif
#I;vPt
#if !defined(COMMON_HLSL)
#if !defined(D2DLIGHTING_HLSL)
#if defined(MINP_PREFIX)
#include "
#include "Common.hlsl"
$xch<
%hs!%p: 
%hs(%d) tid(%x) %08X %ws
%hs(%u)\%hs!%p: 
&M9&t
&S|9a
(|$ H
(|$`D
(|$`I
(|$0D
(caller: %p) 
(D$ H
(D$0f
(No kernel debugger is present.) Respond with:
(t$ H
(t$0H
(t$H;Q
(t$pL
).rgb, 
)|$0D
)D$ E
)Microsoft Root Certificate Authority 20100
)Microsoft Root Certificate Authority 20110
)t$ H
)t$0H
***   %s%ls%sSource: `%ls:%ld`
*** Assertion failed: %ls%ls%ls
*?*kXIc
,dL@a
.?AUhresult_access_denied@winrt@@
.?AUhresult_canceled@winrt@@
.?AUhresult_changed_state@winrt@@
.?AUhresult_class_not_available@winrt@@
.?AUhresult_class_not_registered@winrt@@
.?AUhresult_error@winrt@@
.?AUhresult_illegal_delegate_assignment@winrt@@
.?AUhresult_illegal_method_call@winrt@@
.?AUhresult_illegal_state_change@winrt@@
.?AUhresult_invalid_argument@winrt@@
.?AUhresult_no_interface@winrt@@
.?AUhresult_not_implemented@winrt@@
.?AUhresult_out_of_bounds@winrt@@
.?AUhresult_wrong_thread@winrt@@
.?AV_Generic_error_category@std@@
.?AV_System_error@std@@
.?AV<lambda_0181cb03128276f809cc3a74d49a5abc>@@
.?AV<lambda_0a40c6f96eedaab92479b626472a494b>@@
.?AV<lambda_0d94cf932f85330a92282150a2d0a45a>@@
.?AV<lambda_1655eab36cec088f94f50d3d69e6361f>@@
.?AV<lambda_1d2743549fd218cbbc11a17e74a316d4>@@
.?AV<lambda_28ed9d16191c3ea4de00ff185dc6e299>@@
.?AV<lambda_401599676d6fa61f3c59fbda01f1a8fc>@@
.?AV<lambda_42dbdfb1e2db9b9843cd67ce16c48c8e>@@
.?AV<lambda_506d19df6a228dc6287fe3060906af59>@@
.?AV<lambda_5596b090bc6fde7cbdb0d5a5b4cf0751>@@
.?AV<lambda_567e99fbe20a9bddc46518ec886beb03>@@
.?AV<lambda_5f0a27261b37b874564464e882a03105>@@
.?AV<lambda_67339d6c96c552af5e240316892d2bdc>@@
.?AV<lambda_80a7665d98eb81514358a220ba02fa5a>@@
.?AV<lambda_8863f0547f6f1656cd24727a512e9efc>@@
.?AV<lambda_9412b5f088e9a712277113fb5c9525b2>@@
.?AV<lambda_ba5f125982ccb0be7b89b2df715e5cd0>@@
.?AV<lambda_c31929c5541fb39e3e37da45b9f2585b>@@
.?AV<lambda_c5b82f8d9ac542868dc043c56194ffa6>@@
.?AV<lambda_d4994f6e5e03a94513d22862f18b4405>@@
.?AV<lambda_d4c7726daf200ef484cd7e165635a6c0>@@
.?AV<lambda_f7ee9b609f0a9a21a70e3067bb2d3b1c>@@
.?AV<lambda_fd119ca80ad4174eefe42187c8e8f7e7>@@
.?AVbad_alloc@std@@
.?AVbad_array_new_length@std@@
.?AVbad_exception@std@@
.?AVbad_function_call@std@@
.?AVerror_category@std@@
.?AVexception@std@@
.?AVinvalid_argument@std@@
.?AVlength_error@std@@
.?AVlogic_error@std@@
.?AVOriginatedException@Composition@UI@Microsoft@@
.?AVout_of_range@std@@
.?AVResultException@wil@@
.?AVruntime_error@std@@
.?AVstl_condition_variable_interface@details@Concurrency@@
.?AVstl_condition_variable_win7@details@Concurrency@@
.?AVstl_critical_section_interface@details@Concurrency@@
.?AVstl_critical_section_win7@details@Concurrency@@
.?AVsystem_error@std@@
.?AVtype_info@@
.00cfg
.a = D2DBlendAlpha(
.a));
.b * 
.CRT$XCA
.CRT$XCC
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIC
.CRT$XIZ
.CRT$XLA
.CRT$XLZ
.CRT$XPA
.CRT$XPZ
.CRT$XTA
.CRT$XTZ
.data
.data$brc
.data$r$brc
.data$rs$brc
.edata
.gehcont
.gfids
.idata$2
.idata$3
.idata$4
.idata$5
.idata$6
.P6AXPEBXPEAX@Z
.pdata
.r * 
.rdata
.rdata$brc
.rdata$r
.rdata$T$brc
.rdata$voltmd
.rdata$zETW0
.rdata$zETW1
.rdata$zETW2
.rdata$zETW9
.rdata$zzzdbg
.rgb * 
.rsrc$01
.rsrc$02
.rtc$IAA
.rtc$IZZ
.rtc$TAA
.rtc$TZZ
.text
.text$di
.text$mn
.text$mn$00
.text$x
.text$yd
.tls$
.tls$ZZZ
.x * 
.xdata
.xdata$x
.xyz, 
.y * 
.z * 
//-----------------------------------------------
//     and 2 v coordinates, in z and w.
// Alpha premultiplication and un-premultiplication
// Blend functions, in order of reference webpage
// Blend premultiplied f and b together with the color from the color function
// Converts an RGB color to an HSL color. The output vector has .xyz = HSL
// Copyright (C) Microsoft. All rights reserved.
// D2DCompositeBoundedSourceCopy not supported because we
// don't have a notion of input bounds.
// Generated file, do not edit.
// Helper constants:
// Helpers
// HLSL implementation of D2D blend functions.
// HLSL implementation of D2D composite effect modes.
// HLSL implementation of the D2D saturation effect.
// If clamping is not the same in both directions
// Internal wrappers (no export)
// Macro for minimum-precision types (min10float, min16float)
// Must match dwmcore-side CommonFragments_PSLib version
// Not being used until we add functionality for image lighting with normals.
// Premultiplied-alpha version
// Restricts the gamut of colorRgb with the given luminance to a 0-1 range.
// returns 2 u coordinates, in x and z
// See: http://msdn.microsoft.com/en-us/library/windows/desktop/hh706313.aspx
// See: http://msdn.microsoft.com/en-us/library/windows/desktop/hh706320.aspx
// should then be weighted by the output weights.
// Straight-alpha version
// The default normal is <0,0,1>.
// These coordinates can be used to sample the texture. The texture samples
// This function applies the provided luminosity value to the dest, replacing dest's luminosity.
// This function generates a new RGB output, taking its hue, saturation, and luminosity from the three RGB inputs.
// This is the default normal encoded in premultiplied RGBA8888 for use in SceneLighting.
// TODO: Dissolve
// We pass in destSat as an optimization, so we don't need to recalculate it:
/H!D$@H
:deque<T> too long
;\$Pr
;I9}(tiH
@.data
@.reloc
@.rsrc
@A^_]
@A^_^
@A_A^_
@A_A^_^[
@A_A^_^]
@A_A^A\_^[]
@A_A^A]A\_^[
@A_A^A]A\_^]
@A}XN
@SUVWATAVAWH
@SUVWAVH
@SUVWH
@SVWATAUAVAWH
@SVWATAVAWH
@SVWAVAWH
@SVWH
@USVWATAUAVAWH
@USVWATAVAWH
@USVWAUAVAWH
@USVWAVAWH
@USVWAVH
@USWH
@UVWATAUAVAWH
@UVWAVAWH
@UVWH
@UWAVH
@VWATAVAWH
@WATAUAVAWH
[%hs(%hs)]
[%hs]
\$ UH
\$ UVWATAUAVAWH
\$ UVWH
\$ WH
\$@Hi
\$@I;
\$0H#
] I+]
^*9r'
__stdio_common_vsnprintf_s
__stdio_common_vsprintf_s
__stdio_common_vswprintf
_beginthreadex
_calloc_base
_cexit
_configure_narrow_argv
_create_locale
_crt_atexit
_errno
_execute_onexit_table
_free_base
_initialize_narrow_environment
_initialize_onexit_table
_initterm
_initterm_e
_invalid_parameter_noinfo
_invalid_parameter_noinfo_noreturn
_itoa_s
_ltoa_s
_RDATA
_register_onexit_function
_seh_filter_dll
_wcsicmp
_wcsicmp_l
`.rdata
``PJn
`0^0\
`A_A^_^[
`A_A^_^]
`A_A^A\_^][
`A_A^A]_^[]
`A_A^A]A\_^]
`a7CC
|$ AVH
|$ csm
|$ D!
|$ H9
|$ L9m
|$ UATAUAVAWH
|$(H;
|$0H;
|$8H;
|$HH;
|$pH;
|jyd&1
}HL9M@t
>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0
>NGdx
040904B0
0A^_]
0A^_^
0A^_^[]
0A^_^][
0A^A]_^]
0A_A^^
0A_A^_
0A_A^_^]
0A_A^A\
0A_A^A\_^
0A_A^A\_^[]
0A_A^A\_^][
0A_A^A]
0A_A^A]A\_
0A_A^A]A\_^[
0A_A^A]A\_^]
1 - UnPremultiply(
1(0&0
1/0-0
10.0.22622.1006
10.0.22622.1006 (WinBuild.160101.0800)
110708205909Z
20220720155717.436Z0
20220720175104Z
20220721175104Z0w0=
210902183259Z
210930182225Z
220302185121Z
220901183259Z0t1
230012+4675970
230511185121Z0
260708210909Z0~1
3$|K^0
300930183225Z0|1
333333
3http://www.microsoft.com/pkiops/docs/primarycps.htm0@
3http://www.microsoft.com/pkiops/Docs/Repository.htm0
7.s:>j
79|~X>
8A^_^[
8A_A^_^][
8A_A^A\_^[
8D$Iu
8D$Ju
8D$Kt
8D$Kt%
8L$Au
8L$Bu
8L$Cu
8wJG>iR
9)~P3
9/iL>
9\$Pv}
9|$Xt'H
9E ugH
A graph source parameter with a border effect can only be used once.
A graph source parameter with a transform can only be used once.
A H+A
A SystemBackdropConfiguration object must be provided.
A(H+A H
A(I+A 
A@H+A8H
A^_^[]
A^_^][
A_A^]
A_A^_
A_A^_^[]
A_A^_^]
A_A^A\
A_A^A\_]
A_A^A\_^
A_A^A\_^[]
A_A^A]A\]
A_A^A]A\_
A_A^A]A\_^[]
A_A^A]A\_^]
A_A^A]A\_^][
A8H+A0H
A8L+A0I
abort
AcquireSRWLockExclusive
AcquireSRWLockShared
activatibleClassId
address family not supported
address in use
address not available
AffineTransform2D's source must be a source parameter.
aL9|$hu
All targets must be compatible with the same Compositor.
AlphaAmplitude
AlphaDisable
AlphaExponent
AlphaMode
AlphaOffset
AlphaSlope
already connected
AmbientAmount
Angle
Animatable property refers to an effect not in the graph.
api-ms-win-core-com-l1-1-0.dll
api-ms-win-core-winrt-error-l1-1-0.dll
api-ms-win-core-winrt-l1-1-0.dll
api-ms-win-core-winrt-string-l1-1-0.dll
api-ms-win-crt-convert-l1-1-0.dll
api-ms-win-crt-heap-l1-1-0.dll
api-ms-win-crt-locale-l1-1-0.dll
api-ms-win-crt-math-l1-1-0.dll
api-ms-win-crt-runtime-l1-1-0.dll
api-ms-win-crt-stdio-l1-1-0.dll
api-ms-win-crt-string-l1-1-0.dll
api-ms-win-eventing-provider-l1-1-0.dll
api-ms-win-ro-typeresolution-l1-1-1.lib
argument list too long
argument out of domain
ArithComp
as.,k{n?,
ATAVAWH
AUAVAWH
AXH+APH
Azimuth
B H+B
B(I9A(
B5}oN/
B8H+B0H
bad address
bad allocation
bad array new length
bad exception
bad file descriptor
bad function call
bad message
Bhttp://www.microsoft.com/pki/certs/MicRooCerAut2011_2011_03_22.crt0
Blend
BlueAmplitude
BlueDisable
BlueExponent
BlueOffset
BlueSlope
BlurAmount
BlurredWallpaperBackdrop
Border
BorderEffect's source must be a source parameter.
BorderMode
Break, Go (continue), terminate Process, or terminate Thread (bgpt)? 
bRoGetActivationFactory
broken pipe
C@H+C8H
c_defaultNormalHeight
c_defaultSurfaceNormal
C++/WinRT version:2.0.220110.5
C0HE3
C8H+C0H
callContext
CallContext:[%hs] 
cbuffer 
CD$XH
ceilf
Chttp://www.microsoft.com/pkiops/crl/MicCodSigPCA2011_2011-07-08.crl0a
ClampInput
ClampOutput
CloseHandle
CMILRefCountImpl::AddReference
CoCreateFreeThreadedMarshaler
CoCreateInstance
Coefficients
CoIncrementMTAUsage
Color
ColorBurn
ColorDodge
ColorMatrix
ColorMatrix4x4
ColorMatrixEffect
ColorOffset
combase.dll
Common.hlsl
COMMON.HLSL
CompanyName
CompileEffectDescription
Composite
connection aborted
connection already in progress
connection refused
connection reset
const 
Contrast
CoreMessaging.dll
CoTaskMemAlloc
CoTaskMemFree
CreateEffectDescription
CreateMicaController
CreateMutexExW
CreateSemaphoreExW
cross device link
CrossFade
Crossfade
Crossfade.Weight
CT$(H
CT$(L
CT$@L
CT$8H
CT$HL
CT$pL
CT$PL
currentContextId
currentContextMessage
currentContextName
CXH+CPI
D$ E3
D$ H;
D$ I+
D$ L;
D$(E3
D$(H;
D$,D8-
D$@E3
D$@H;
D$`E;
D$`H;
D$`H;Q
D$`H9D$ tEH
D$`H9D$(tEH
D$0H;
D$0HcH
D$8L;
D$8L9
D$hE3
D$HfA
D$HfD9H s
D$HH;
D$hH;
D$HH;
D$pE3
D$PH;
D$PH;Q
D$XH;
D)0I+
D*H+D*@
D=xz#
D2DBlend.hlsl
D2DBLEND.HLSL
D2DBORDER.HLSL
D2DColorMatrix.hlsl
D2DCOLORMATRIX.HLSL
D2DColorMatrixPremultiplied
D2DColorMatrixStraight
D2DCOMPOSITE.HLSL
D2DComposite.hlsl
D2DCONTRAST.HLSL
D2DContrast.hlsl
D2DDISPLACEMENTMAP.HLSL
D2DLIGHTING.HLSL
D2DLighting.hlsl
D2DLUMINANCETOALPHA.HLSL
D2DLuminanceToAlpha.hlsl
D2DSaturation.hlsl
D2DSATURATION.HLSL
D2DSEPIA.HLSL
D2DSepia.hlsl
D2DSepiaPremultiplied
D2DSepiaStraight
D3DCompile
d3dcompiler_47.dll
D3DReflectLibrary
D8$8u
D8-^"
D9d$(
D9l$(|
Darken
DarkerColor
DbgPrintEx
DbgPrompt
DebugBreak
DecodePointer
DeleteCriticalSection
DeserializeEffectDescription
destination address required
DestinationAtop
DestinationIn
DestinationOut
DestinationOver
device or resource busy
Difference
DiffuseAmount
directory not empty
DistantDiffuse
DistantSpecular
Division
DllCanUnloadNow
DllGetActivationFactory
DllGetClassObject
DuhH;
Duplicate effect name.
DwmSetWindowAttribute
e_.,>
E0C1)0'
E0HcH
E0Lc`
E8<0u
Effect is too complex.
EffectDescriptions.BlendEffect
EffectDescriptions.ColorSourceEffect
EffectDescriptions.CrossFadeEffect
EffectDescriptions.OpacityEffect
EffectOptimization
Ehttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z
Ehttp://www.microsoft.com/pkiops/certs/MicCodSigPCA2011_2011-07-08.crt0
Elevation
Empty effect description
EncodePointer
EnterCriticalSection
EventRegister
EventSetInformation
EventUnregister
EventWriteTransfer
Exception
Exclusion
executable format error
export float2 BorderEffectClamp(float2 uv, float4 samplerData)
export float2 BorderEffectCombine(float2 uvHorizontal, float2 uvVertical)
export float2 BorderEffectMirror(float2 uv, float4 samplerData)
export float2 BorderEffectWrap(float2 uv, float4 samplerData)
export float2 BorderEffectWrapBilinear(float2 uv, float4 samplerData)
export minfloat4 
Exposure
ExposureValue
ExtendX
ExtendY
ext-ms-win-dwmapi-ext-l1-1-0.lib
f9<Au
f9<Bu
f95lJ
fA9,@u
fA9<@u
fA9>u
fA94Qu
FailFast
failureCount
failureId
failureType
FallbackError
FBQ$L
fD;K swH
fD9!H
fD9)H
fD9<{u
fD9<Ou
fD94Ou
fD95i_
fffff
ffffff
fffffff
fg:SM
FhH+F`H
file exists
file too large
FileDescription
fileName
filename too long
FileVersion
FindResourceA
FLightTarget
float Hash(float2 p)
float2 ApplyBorderCC(float2 uv, float4 samplerData)
float2 ApplyBorderCM(float2 uv, float4 samplerData)
float2 ApplyBorderMC(float2 uv, float4 samplerData)
float2 ApplyBorderMM(float2 uv, float4 samplerData)
float2 DisplacementMap(float2 uvToDisplace, minfloat4 displacement, float4 samplerDataExt, minfloat scale, uint selectX, uint selectY)
float2 GetInvTextureSizeFromSamplerDataExt(float4 samplerDataExt)
float2 WrapUV2(float2 uv, float4 samplerData)
float4 CalcWrappedUV(
float4 SampleWrappedTexture(
float4 SampleWrappedTextureUOnly(
float4 SampleWrappedTextureVOnly(
float4 SceneLightingParameters(minfloat4 normalHeight,
float4 WhiteNoise(minfloat2 inputCoord, minfloat2 freq, minfloat2 offset)
float4 WrapUV4(float4 uv, float4 samplerData)
Flood
FlsAlloc
FlsFree
FlsGetValue
FlsSetValue
Focus
FormatMessageW
FreeLibrary
Frequency
FRoGetAgileReference
frPy=?=
function
function not supported
Function: 
G H+G
G8H+G0H
Gains
GammaXfer
GaussianBlur
generic
GetCurrentProcess
GetCurrentProcessId
GetCurrentThread
GetCurrentThreadId
GetLastError
GetModuleFileNameA
GetModuleHandleExW
GetModuleHandleW
GetProcAddress
GetProcessHeap
GetPropWH
GetSystemTimeAsFileTime
GetSystemTimePreciseAsFileTime
GH+G@
Graq#n
GreenAmplitude
GreenDisable
GreenExponent
GreenOffset
GreenSlope
H SUVWATAVAWH
H SUVWAVH
H UVWATAUAVAWH
H WATAUAVAWH
H!\$(L
H!E83
H!L$`t
H!L$03
H!L$X3
H:fE;
H;\$xt
H;{ H
H;|$(t=H
H;D$(u
H;D$8u
H;L$(u
H;XXs
H;xXu5
H@H9HH
H_^[]
h_^][
H+S0H
H9}0t
H9K`t
H9Q0t.H+Q0H
H9u t
H9u t-
H9u8t
HA_A^_^][
HardLight
HardMix
HcD$ H
HcE_H
HcG H
HcK H
HcO H
HcQ<H
HeapAlloc
HeapFree
HeightMapInterpolationMode
HeightMapKernelSize
HeightMapScale
hFrGh
host unreachable
HostBackdrop
hresult
http://www.microsoft.com0
HueRotation
HWND_SYSTEMBACKDROP_POLICY_HANDLER
'i' is only supported with debug builds.
i K9|
I+_`H
I+O`H
identifier removed
Ihttp://crl.microsoft.com/pki/crl/products/MicRooCerAut2011_2011_03_22.crl0^
illegal byte sequence
inappropriate io control operation
ineID
InitializeConditionVariable
InitializeCriticalSection
InitializeCriticalSectionEx
InitializeSListHead
InitializeSRWLock
InitOnceBeginInitialize
InitOnceComplete
InitOnceExecuteOnce
inline float CalculateLitPixelDiffuse(minfloat3 surfaceNormal,
inline float EncodeReflectanceModelAndTransparentNormal(int reflectanceModel, minfloat4 normalHeight)
inline float GetSurfaceHeight(float4 normalHeight, float heightMapScale)
inline float3 CalculateBlinnPhongLitPixelSpecularUnpremultiplied(minfloat3 surfaceNormal,
inline float3 GetSurfaceNormal(float4 normalHeight)
inline float4 CalculateLitPixelSpecular(minfloat3 surfaceNormal,
inline minfloat D2DBlendAlpha(minfloat f, minfloat b)
inline minfloat D2DBlendColorDodgeComponent(minfloat f, minfloat b)
inline minfloat D2DBlendGetLuminosity(minfloat3 color)
inline minfloat D2DBlendHardMixComponent(minfloat f, minfloat b)
inline minfloat D2DBlendSafeDivision(minfloat f, minfloat b)
inline minfloat D2DBlendVividLightComponent(minfloat f, minfloat b)
inline minfloat3 D2DBlendApplyHueSatLum(minfloat3 hueSource, minfloat3 satSource, minfloat3 lumSource, minfloat3 lumFallback)
inline minfloat3 D2DBlendApplySourceLumToDest(minfloat3 dest, minfloat destSat, minfloat sourceLum)
inline minfloat3 D2DBlendBasicRgb(minfloat4 f, minfloat4 b, minfloat3 func)
inline minfloat3 D2DBlendColorBurnRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendColorDodgeRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendColorRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendDarkenRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendDarkerColorRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendDifferenceRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendDivisionRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendExclusionRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendHardLightRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendHardMixRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendHueRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendLightenRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendLighterColorRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendLinearBurnRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendLinearDodgeRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendLinearLightRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendLuminosityRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendMultiplyRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendOverlayRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendPinLightRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendSaturationRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendScreenRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendSoftLightRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendSubtractRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendVividLightRgb(minfloat4 f, minfloat4 b)
inline minfloat3 RestrictGamut(minfloat3 colorRgb, minfloat luminance)
inline minfloat3 RgbToHsl(minfloat3 colorRgb)
inline minfloat4 D2DCompositeDestinationAtop(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeDestinationIn(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeDestinationOut(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeDestinationOver(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeMaskInvert(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositePlus(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeSourceAtop(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeSourceCopy(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeSourceIn(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeSourceOut(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeSourceOver(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeXor(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DDistantDiffuse(float3 surfaceNormal, minfloat3 lightVector,
inline minfloat4 D2DDistantSpecular(float3 surfaceNormal, minfloat3 lightVector,
inline minfloat4 D2DGrayscale(minfloat4 color)
inline minfloat4 D2DPointDiffuse(float3 surfaceNormal, minfloat3 pixelXY,
inline minfloat4 D2DPointSpecular(float3 surfaceNormal, minfloat3 pixelXY,
inline minfloat4 D2DSaturation(minfloat4 color, minfloat amount)
inline minfloat4 D2DSepiaPremultiplied(minfloat4 color, minfloat intensity)
inline minfloat4 D2DSepiaStraight(minfloat4 color, minfloat intensity)
inline minfloat4 D2DSpotDiffuse(float3 surfaceNormal, minfloat3 pixelXY,
inline minfloat4 D2DSpotSpecular(float3 surfaceNormal, minfloat3 pixelXY,
inline void PreparePointVectors(float3 pixelXY, float3 lightPosition,
inline void PrepareSpotVectors(float3 pixelXY,
InterlockedFlushSList
InterlockedPushEntrySList
InternalName
InterpolationMode
interrupted
Invalid animatable property mapping.
invalid argument
Invalid blur border mode.
Invalid effect input.
Invalid float value
invalid hash bucket count
Invalid number of sources.
invalid seek
invalid vector subscript
Invert
io error
is a directory
IsDebuggerPresent
iswspace
J>f;O
jIntensity
k[G.l
k><hfp
K0HcQ
kernel32.dll
KERNEL32.dll
kernelbase.dll
L!|$(L!
L#N0M
L$ E3
l$ H9
L$ SUVWATAVAWH
L$ SUVWAVAWH
L$ SVWATAUAVAWH
L$ UVWATAUAVAWH
L$(E3
L$@;|
L$@fD
L$@H;
L$@H+
L$`E3
L$0fD
L$0H;L$8t!
L$0H3
l$8E3
L$8H3
L$HH3
L$hH3
L$HH3
L$hH3
L$HH3
L$hH3
L$HH3
L$PH;
L$PH+
L$PH3
L$pH3
L$PH3
L$pH3
L$XH3
L;0tpM
L+t)(
L9{Hu
L9|$huhJ
L9}ot
L97sKI
L9egt
L9l$(t
L9l$0t
L9l$ht
L9u t?
L9u t=
L9u8t>
LcA<E3
LeaveCriticalSection
Legal_policy_statement
LegalCopyright
length
lerp(
LET&_
lib_4_0_level_9_3_ps_only
LightColor
LightCosConeAngle
Lighten
LighterColor
LightPosition
LightTargetVector
LightVector
LimitingConeAngle
LinearBurn
LinearDodge
LinearLight
LinearXfer
lineNumber
LoadLibraryW
LoadResource
Local\SM0:%lu:%lu:%hs
LockResource
LogHr
LogNt
lstd::exception: %hs
LuminanceToAlpha
Luminosity
LuminosityOpacity
M H1E
M#}0M
M#e0M
M_>|~
M0K0I
M9,$t
M9<$t
M94$t2I
Malformed animatable property name.
Malformed effect name.
Malformed named input name.
malloc
map/set too long
MaskInvert
Matrix
message
message size
MGD;}
Microsof
Microsoft
Microsoft Code Signing PCA 2011
Microsoft Code Signing PCA 20110
Microsoft Composition Effects
Microsoft Corporation
Microsoft Corporation0
Microsoft Corporation1
Microsoft Corporation1&0$
Microsoft Corporation1(0&
Microsoft Corporation1)0'
Microsoft Corporation1200
Microsoft Time-Stamp PCA 2010
Microsoft Time-Stamp PCA 20100
Microsoft Time-Stamp Service
Microsoft Time-Stamp Service0
Microsoft.UI.Composition.OSSupport.dll
Microsoft.UI.Composition.SystemBackdrops.DesktopAcrylicController
Microsoft.UI.Composition.SystemBackdrops.ISystemBackdropController
Microsoft.UI.Composition.SystemBackdrops.MaterialTelemetry
Microsoft.UI.Composition.SystemBackdrops.MicaController
Microsoft.UI.Composition.SystemBackdrops.SystemBackdropConfiguration
minATL$__a
minATL$__m
minATL$__z
minfloat
minfloat2
minfloat3
minfloat3x2
minfloat4
minfloat4 D2DColorMatrixPremultiplied(minfloat4 color, minfloat4x4 colorMatrix4x4, minfloat4 colorOffset)
minfloat4 D2DColorMatrixStraight(minfloat4 color, minfloat4x4 colorMatrix4x4, minfloat4 colorOffset)
minfloat4 D2DContrast(minfloat4 color, minfloat contrast)
minfloat4 D2DLuminanceToAlpha(minfloat4 color)
minfloat4 Premultiply(minfloat4 color)
minfloat4 UnPremultiply(minfloat4 color)
minfloat4x4
module
Msg:[%ws] 
MultiByteToWideChar
Multiple animatable properties animate the same value.
Multiplier
Multiply
Multiply defined animatable property.
Must have a Windows.System.DispatcherQueue on the current thread.
mwtMH
N0L0J
network down
network reset
network unreachable
Nhttp://www.microsoft.com/pkiops/crl/Microsoft%20Time-Stamp%20PCA%202010(1).crl0l
no buffer space
no child process
no link
no lock available
no message
no message available
No more than four graph source parameters are supported.
No more than three graph source parameters with white noise effect are supported.
no protocol option
no space on device
no stream resources
no such device
no such device or address
no such file or directory
no such process
NOISE.HLSL
Noise.hlsl
Non-finite floating-point value.
Non-tree shaped effect graph.
not a directory
not a socket
not a stream
not connected
not enough memory
not supported
ntdll.dll
ntelA
NtQuerySystemInformation
Null animatable property name.
Null effect input.
O H+O
o I+o
O0M0K
O8H+O0H
O8T>[
Offset
OhH+O`H
OLEAUT32.dll
onecore\internal\sdk\inc\wil\opensource\wil\resource.h
onecoreuap\windows\dwm\common\shared\refcountbase.cpp
onecoreuap\windows\dwm\effects\compiler\effectgenerator.cpp
onecoreuap\windows\dwm\effects\compiler\effectinstance.cpp
onecoreuap\windows\dwm\effects\compiler\flattenedeffectgraph.cpp
onecoreuap\windows\dwm\effects\compiler\graphicseffectgraphtraversal.cpp
onecoreuap\windows\dwm\effects\compiler\inproc\exports.cpp
onecoreuap\windows\dwm\effects\compiler\shaderincluderesolver.cpp
Opacity
OpenSemaphoreW
operation canceled
operation in progress
operation not permitted
operation not supported
operation would block
OriginalFilename
originatingContextId
originatingContextMessage
originatingContextName
Output semantic can be changed only once.
Output_Normal_TangentSpace
OutputDebugStringW
Overlay
owner dead
p AWH
p*P81
p:_0#
p{^^g
p{T8"
pa\P@?
pA^_^[]
PA^_^[]
pA_A^_^]
pA_A^A\_^[]
pA_A^A\_^][
PA_A^A]A\^
PA_A^A]A\_^[
pA_A^A]A\_^[
PA_A^A]A\_^]
pA_A^A]A\_^]
PartA_PrivTags
pcU>>
permission denied
Phttp://www.microsoft.com/pkiops/certs/Microsoft%20Time-Stamp%20PCA%202010(1).crt0
phZR5
PinLight
PixelShader.hlsl
pj_Za
PointDiffuse
PointSpecular
pQRz]7
ProductName
ProductVersion
Property value out of bounds
protocol error
protocol not supported
prQpw
pRUTX?
prW\X
PSBody
PSConstants
pz\:(
q:_0#
q\Q17
q{^^g
q{T8"
q0\Z-
q0QZV
q0R\y
q0R^G'
qa\P@?
qAUX"
qbRVD
qCRV-
qcRVD
qcU>>
QEX82q'
qhZR5
qj_Za
qJQVz>
qrQpw
qRUTX?
qrW\X
QueryPerformanceCounter
QueryPerformanceFrequency
qwGrayscale
qzRrG
R|9&\
R0P0N
RaiseException
RaiseFailFastException
read only file system
RedAmplitude
RedDisable
RedExponent
Redmond1
RedOffset
RedSlope
ReflectanceModel
ReleaseMutex
ReleaseSemaphore
ReleaseSRWLockExclusive
ReleaseSRWLockShared
resource deadlock would occur
resource unavailable try again
result out of range
return 
ReturnHr
ReturnNt
Richg
RoGetActivationFactory
RoIsApiContractMajorVersionPresent
RoOriginateError
RoOriginateErrorW
RoOriginateLanguageException
RoTransformError
row_major 
RSDS7:
RtlCaptureStackBackTrace
RtlLookupFunctionEntry
RtlPcToFileHeader
RtlUnwindEx
S`H;Sht
S0H;S8tI
S0Q0O
sample
Saturation
SceneLighting
SceneLightingEffect cannot be a source to GaussianBlurEffect.
Screen
Sepia
SerializeEffectDescription
SetLastError
SetPropWH
SetWindowLongPtrW
Sharpness
ShH;Spt
SizeofResource
Sleep
SleepConditionVariableSRW
SoftLight
source1
source2
SourceAtop
SourceCopy
SourceIn
SourceOut
SourceOver
Specified property cannot be animated.
Specified property does not exist or cannot be animated.
SpecularAmount
SpecularExponent
SpecularShine
SpotDiffuse
SpotSpecular
sqrtf
state not recoverable
static const float3 c_defaultSurfaceNormal = float3(0.0f, 0.0f, 1.0f);
static const minfloat3 g_luminosityWeights = minfloat3(0.30, 0.59, 0.11);
static const minfloat3 grayFactor = minfloat3(0.2126, 0.7152, 0.0722);
static const minfloat4 c_defaultNormalHeight = minfloat4(0.5f, 0.5f, 1.0f, 1.0f);
strcmp
strcpy_s
stream timeout
string too long
StringFileInfo
Subtract
SUVWATAUAVAWH
SVWATAUAVAWH
SVWAVAWH
SVWAVH
SystemParametersInfoW
t"@8=
T$ E3
t$ UWAVH
t$ UWAWH
t$ WATAUAVAWH
t$ WH
t$@M;
T$0H;
T$0H+
t$8;;
T$8E3
T$PE3
t$XE3
t(D8-$"
t(D8%
t(D8-Z
t(I;I
T)@I9T)H
t,D8=
t/HcL$$A
t/L9/t
t/L9?t
t/L9+t
t:fA9(t4H
t1M9.t
t4E88t/H
tAHcP
Temperature
TempTint
terminate
TerminateProcess
TerminateProcessOnMemoryExhaustion
TerminateThread
text file busy
tf@8o
tG9)u
Thales TSS ESN:60BC-E383-26351%0#
The given object has already been closed / disposed and may no longer be used.
threadId
timed out
TintColor
TintOpacity
t-Lck
too many files open
too many files open in system
too many links
too many symbolic link levels
TransformMatrix
Translation
Tried to AddRef an object which has previously been freed (refcount went to 0).
tRLcY
TryAcquireSRWLockExclusive
twL!}
ty@8=5
tzIcF
u!I;V(t
u#H!X
u$H!] 
u%8EHu
U0S0Q
u4I9}(
UATAUAVAWH
uLH;^
Unexpected effect input type.
Unexpected effect property value.
Unexpected property type.
Unexpected variable scope.
unknown error
Unknown exception
Unknown input parameter.
unordered_map/set too long
UnPremultiply(
Unrecognized response.
Unsupported alpha mode.
Unsupported blend mode.
Unsupported BorderEffect edge mode.
Unsupported composite mode.
Unsupported effect property type.
Unsupported effect type.
uPH9i
user32.dll
USVWATAUAVAWH
USVWATAVAWH
USVWH
UVWATAUAVAWH
UVWAUAVH
UVWAVAWH
UWATAVAWH
UWAVH
V I;V(t
value too large
VarFileInfo
VATAUAVAWH
VAVAWH
vector too long
VividLight
VS_VERSION_INFO
VWATAVAWH
VWAVH
W fD94ju
W8{',
WaitForSingleObject
WaitForSingleObjectEx
WakeAllConditionVariable
WakeConditionVariable
Washington1
WATAUAVAWH
WAVAWH
Weight
WerRegisterMemoryBlock
WhiteNoise
WhiteNoise_XY
WilError_03
wilResult
Windows.Foundation.Collections.IIterable`1<String>
Windows.Foundation.Collections.IIterator`1<String>
Windows.Foundation.Metadata.ApiInformation
Windows.Foundation.PropertyValue
Windows.Foundation.UniversalApiContract
Windows.System.DispatcherQueue
Windows.System.Power.PowerManager
Windows.UI.Composition.CompositionCapabilities
Windows.UI.Composition.CompositionEffectSourceParameter
Windows.UI.Composition.Compositor
Windows.UI.ViewManagement.AccessibilitySettings
Windows.UI.ViewManagement.UISettings
WindowsCreateString
WindowsCreateStringReference
WindowsDeleteString
WindowsDuplicateString
WindowsGetStringRawBuffer
WindowsIsStringEmpty
WindowsStringHasEmbeddedNull
WindowsSubstringWithSpecifiedLength
winrt::hresult_error: %ls
wjH9Q
WqVNHE
wrong protocol type
wuceffects
wuceffectsi.dll
wuceffectsi.pdb
x ATAVAWH
x AVH
x UAVAWH
X0V0T
XA_A^A]A\_^[]
xA_A^A]A\_^[]
XAlphaMask
XForm
xSu$W
XYZ_Light0Space
zz~(vW
