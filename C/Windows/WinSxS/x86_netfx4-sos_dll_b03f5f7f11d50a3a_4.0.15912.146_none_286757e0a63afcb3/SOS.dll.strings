----------------
-----------------------
-----------------------------
------------------------------
----------------------------------
-----------------------------------
--------------------------------------
---------------------------------------
---------------------------------------------
---------------------------------------------------------
--------------------------------------------------------------------------
----------------------------------------------------------------------------
------------------------------------------------------------------------------
-------------------------------------------------------------------------------
--------------------------------------------------------------------------------------
    ------------------------------------------------------------------------------
     
-----------------------------      -----------------------------
        
                          
                                                                
                                          PreEmptive   GC Alloc           Lock
                                      expand the base type of 'var1' to show you its
                                      fields.
                                   COMState
                                  detailed logs are generated.  The maximum 
                                  isn't specified)
                                  specified)
                                  specified.  The higher the number the more
                                  This is also the default value if the key 
                                  value is decimal 10)
                               at index 6 in the array, along with its fields
                               for frame 2.
                               'var1.abc' to show you the fields of the 'abc' field,
                       [<pseudo-register number for result>]
                      not print fields of the elements. Useful for arrays of
                      objects like String
                      of the element using !DumpObj and !DumpVC format.
                      Specify from which index the command shows the elements.
                      Specify how many elements to show.
                  %8s     %8s
                  String
                 [<Pseudo-register number>]
                 [-create | -create2] 
                 <Exception> 
                ...
                <member address="0x00b75088" />
                debugged on an AMD64 machine.
                in the version directory or on the symbol path
                mscordacwks_<arch>_<arch>_<version>.dll is on your symbol path.
                on an X86 or an ARM machine; an AMD64 dump file must be
                the dump file. For example, an ARM dump file must be debugged
                the handles reside.
            ...
            ...                                  ...
            [E%cP-%02XH] 
            [E%cP+%02XH] 
            </object>
            <object address="0x00b73030" typeid="1" size="300"/>
            <object address="0x00b75054" typeid="5" size="20">
            <root kind="handle" address="0x00a73ff0"/>
            <root kind="stack" address="0x0069f0e0"/>
            <type id="1" name="System.String">
            ->  %p %S%s
            2) the file mscordacwks.dll that matches your version of clr.dll is 
            3) or, if you are debugging a dump file, verify that the file 
            4) you are debugging on supported cross platform architecture as 
            iptrMask = %02X
            thisptr in 
            thisptr in %s
           !soe -derived System.IOException 4;
           .if(@$t3==1 || @$t4==1) { .echo 'stop' } .else {g}"
           AsyncPinned
           concurrent GC and server GC), Debugger helper threads, Finalizer 
           ID OSID ThreadOBJ    State     GC       Context       Domain   Count APT Exception
           output. Example of special threads include: GC threads (in 
           Pinned
           RefCounted
           SizedRef
           so they might not be shown in the first part of the command's 
           Strong
           threads created by CLR. Those threads might not be managed threads 
           threads, AppDomain Unload threads, and Threadpool timer threads.
           Variable
           WeakLong
           WeakShort
           what they point to.
          !Name2EE *!System.String
          (During plan phase, the heap is often not walkable because objects 
          [-dead]
          [-live]
          [-max <size>] 
          [-min <size>] 
          [-mt <MethodTable address>] 
          [-short]
          [start [end]]
          [-startAtLowerBound]
          [-strings] 
          [-thinlock] 
          [-type <partial type name>] 
          adding the size to the start address given as parameters.) 
          address range, !DumpHeap will start its walk from the beginning of 
          all objects in the finalizable and "ready for finalization" queues.
          are being moved. In this case, DumpHeap may report spurious errors, 
          are no longer rooted.  This option can be very expensive, as it 
          cleaned up, and on any RuntimeCallableWrappers (RCWs) that await 
          cleanup.  Both of these data structures are cached and cleaned up by 
          command for automation.
          conjunction with -allReady it enumerates all objects that have a 
          documentation for more info)
          finalizer that are no longer rooted.  If used independently it lists 
          Force heap walk to begin at lower bound of a supplied address range.
          good object as the lower bound for this to work. Display memory at 
          in particular bad objects. It may be possible to traverse more of 
          memcopy, You may also be able to find the next object's address by 
          MT    Count    TotalSize Class Name
          MT    Field   Offset                 Type       Attr    Value Name
          next full GC)
          not in the "Ready for finalization" list are finalizable objects that 
          range, it will stop before displaying the part of the heap in which 
          rooted or not.
          string provided. 
          table (use !dumpmt to verify). If the GC is currently in a call to 
          that are ready for finalization, whether they are already marked by 
          the address of the bad object to manually find the next method 
          the finalizer thread when it gets a chance to run.
          the GC as such, or whether the next GC will.  The objects that are 
          the heap after the reported bad object. Even if you specify an 
          the heap by default. If it finds a bad object before the specified 
          to easily pipe output from the command to another debugger 
          verifies whether all the objects in the finalizable queues are still 
          walk at the specified lower bound. You must supply the address of a 
          you are interested. This switch will force !DumpHeap to begin its 
         (((((                  H
         RCW  CONTEXT   THREAD Apartment
        %S
        ....
        /i <IL pointer>
        {                                    {
        }                                    }
        </objects>
        </roots>
        </types>
        <DynamicMethodDesc pointer> |
        <MethodDesc pointer> |
        <objects>
        <roots>
        <types>
        Background
        call %d [ 
        call [ 
        CLR Owns
        CoInitialized
        In Multi Threaded Apartment
        kill args %2d
        Legal to Join
        lock(r2)                             lock(r1)
        o = (Object *) o + o.Size();
        o.ValidateAllFields();
        on GC entry available commit space was 500 MB
        Pinned Handles:       5
        pop %2d 
        pop %d
        push
        push non-ptr (%d)
        push ptr %2d
        reg %s becoming %s
        Strong Handles:       14
       !bpmd myapp.exe MyApp.Main
       .load <the full path to sos.dll>
       .loadby sos clr
       0    1  250 0019b068      a020 Disabled 02349668:02349fe8 0015def0     0 MTA
       0 028970d4 
       2    2  944 001a6020      b220 Enabled  00000000:00000000 0015def0     0 MTA (Finalizer)
       push %d
       sxe -c "" clrn
       use * for module_name to search all loaded modules
       You can pass * for module_name to search all modules.
      (                          
      1d4140   192178        0       MTA
      1d54e0   192008   181180       STA
      1dff50   192178        0       MTA
      Handle Type          Object     Size RefCount Type
      MT    Count TotalSize Class Name
      MT    Field   Offset                 Type       Attr    Value Name
      MT    Field   Offset                 Type  VT     Attr    Value Name
      MT    TypeDef Name
      MT    TypeRef Name
      path points to those PDBs.
      Vista onwards should have .Net Framework installed by default.
     "CLR notification: module 'mscorlib' loaded"
     (C:\bugs\225271\arraytest.exe)
     28435a0        ?   3f6a8c System.TypedReference
     28435b4        ?   214d6c System.ValueType
     28435c8        ?   216314 System.Enum
     28435dc        ?   2147cc System.Object
     284365c        ?   3cd57c System.IntPtr
     2843670        ?   3feaac System.Byte
     2843684        ?  23a544c System.IEquatable`1[[System.IntPtr, mscorlib]]
     2843784        ?   3c999c System.Int32
     2843798        ?   3caa04 System.IEquatable`1[[System.Int32, mscorlib]]
     322 028970d4 01e411b8, 
     322 028970e8 5b6c5cd8       yes Duplicate promote/relocs
     Address   Domain       MT Type Name              
     ID     TEB   APT    APTId CallerTID Context
     IL associated with the dynamic method.
     IL.
     just pass it as the first argument.
     see the breakpoint listed.
     Start the debugger and type: 
     the IL address.  This is useful for writers of profilers that instrument
     the pointer as the first argument. 
     You can wait for clr to load and then find it.
    ".loadby sos clr"
    "CLR notification: module 'mscorlib' loaded"
    "lmvm clr"
    "sxd clrn"    
    "sxe clrn"
    %p
    %p %p %s
    %p %p %S
    %p %S
    %p (%s handle)
    %s
    %s [%S @ %d]
    (... possibly more reverted versions ...)
    ...
    [DEFAULT] [hasThis] __Canon (Class System.Collections.Generic.IEnumerable`1<__Canon>)
    [DEFAULT] [hasThis] Void (Boolean,String,String)
    [FIELD] ValueClass System.RuntimeTypeHandle 
    __Canon
    {
    {                                    {
    { ... }
    }
    }                                    }
    </gcheap>
    <gcheap>
    <member address="0x%p"%s/>
    -> %p %S%s
    >> Domain:Value 
    >> Thread:Value
    0:000> !DumpRuntimeTypes
    0:000> !dumpsig 00000000`00bc2437 000007ff00043178 
    0:000> !dumpsig 0x000007fe`eb7fd8cd 0x000007fe`eabd1000
    0:000> !dumpsig 0x000007fe`ec20879d 0x000007fe`eabd1000
    0:000> !dumpsigelem 00000000`00bc2437+2 000007ff00043178 
    0:000> !dumpsigelem 00000000`00bc2437+4 000007ff00043178 
    0:000> !dumpsigelem 0x000007fe`eb7fd8cd+1 0x000007fe`eabd1000
    0:000> !dumpsigelem 0x000007fe`ec20879d+2 0x000007fe`eabd1000
    0:000> !dumpsigelem 0x000007fe`ec20879d+3 0x000007fe`eabd1000
    0:000> !dumpsigelem 0x000007fe`ec20879d+4 0x000007fe`eabd1000
    0:000> !dumpsigelem 0x000007fe`ec20879d+5 0x000007fe`eabd1000
    0:000> !GCHandles
    0:002> !rcwcleanuplist 001c04d0 
    0:003> !Threads
    0:003> !ThreadState b220
    001611c0 Strong      01d00b58       84          System.IndexOutOfRangeException
    001611c4 Strong      01d00b58       84          System.IndexOutOfRangeException
    001611c8 Strong      01d1b48c       40          System.Diagnostics.LogSwitch
    001611d0 Strong      01cfd2c0       36          System.Security.PermissionSet
    001611d4 Strong      01cf7484       56          System.Object[]
    001611d8 Strong      01cf1238       32          System.SharedStatics
    001611dc Strong      01cf11c8       84          System.Threading.ThreadAbortException
    001611e0 Strong      01cf1174       84          System.Threading.ThreadAbortException
    001611e4 Strong      01cf1120       84          System.ExecutionEngineException
    001611e8 Strong      01cf10cc       84          System.StackOverflowException
    001611ec Strong      01cf1078       84          System.OutOfMemoryException
    001611f0 Strong      01cf1024       84          System.Exception
    001611f8 Strong      01cf2068       48          System.Threading.Thread
    001611fc Strong      01cf1328      112          System.AppDomain
    001613ec Pinned      02cf3268     8176          System.Object[]
    001613f0 Pinned      02cf2258     4096          System.Object[]
    001613f4 Pinned      02cf2038      528          System.Object[]
    001613f8 Pinned      01cf121c       12          System.Object
    001613fc Pinned      02cf1010     4116          System.Object[]
    2285 028970d4 00223fc4, 01e411b8, 
    2285 028970d4 5b6c5cd8       yes 
    2286 028970d4 00223fc4, 01e411b8, 
    2286 028970d4 5b6c5cd8       yes 
    2287 028970d4 00223fc4, 01e411b8, 
    2287 028970d4 5b6c5cd8       yes 
    2288 028970d4 00223fc4, 01e411b8, 
    2288 028970d4 5b6c5cd8       yes 
    2289 028970d4 00223fc4, 01e411b8, 
    2289 028970d4 5b6c5cd8       yes 
    2290 028970d4 00223fc4, 01e411b8, 
    2290 028970d4 5b6c5cd8       yes 
    2291 028970d4 00223fc4, 01e411b8, 
    2291 028970d4 5b6c5cd8       yes 
    2292 028970d4 00223fc4, 01e411b8, 
    2292 028970d4 5b6c5cd8       yes 
    2293 028970d4 00223fc4, 01e411b8, 
    2293 028970d4 5b6c5cd8       yes 
    2294 028970d4 00223fc4, 01e411b8, 
    2294 028970d4 5b6c5cd8       yes 
    2295 028970d4 00223fc4, 01e411b8, 
    2295 028970d4 5b6c5cd8       yes 
    2295 028970d4 Promotion for root 01e411b8 (MT = 5b6c5cd8)
    2295 028970d4 Relocation NEWVALUE for root 00223fc4
    2295 028970d4 Relocation NEWVALUE for root 01e411b8
    2296 028970d4 00223fc4, 01e411b8, 
    2296 028970d4 5b6c5cd8       yes 
    2296 028970d4 Promotion for root 01e411b8 (MT = 5b6c5cd8)
    2296 028970d4 Relocation NEWVALUE for root 00223fc4
    2296 028970d4 Relocation NEWVALUE for root 01e411b8
    563208d0        5        16972 System.Object[]
    563266dc        1           12 System.Object
    563270c4        1           84 System.Exception
    563272ac        1           84 System.OutOfMemoryException
    56327304        1           84 System.StackOverflowException
    5632735c        1           84 System.ExecutionEngineException
    563273b4        2          168 System.Threading.ThreadAbortException
    5632759c        1           48 System.Threading.Thread
    56328914        1          112 System.AppDomain
    56329708        1           32 System.SharedStatics
    5632bc38        1           36 System.Security.PermissionSet
    56335f78        2          168 System.IndexOutOfRangeException
    5635f934        1           40 System.Diagnostics.LogSwitch
    5b9a628c  4000001        0         System.Int32   instance        2 x
    5b9a628c  4000001        0         System.Int32   instance        3 x
    5b9a628c  4000001        0         System.Int32   instance        4 x
    5b9a628c  4000002        4         System.Int32   instance        4 y
    5b9a628c  4000002        4         System.Int32   instance        6 y
    5b9a628c  4000002        4         System.Int32   instance        8 y
    5b9a628c  4000003        8         System.Int32   instance        6 z
    5b9a628c  4000003        8         System.Int32   instance        9 z
    5b9a628c  4000003        8         System.Int32   instance       12 z
    Abort Initiated
    Aborted
    Addr     Size Followed by
    APPDOMAIN    0x02000000
    argTabOffset = %x  
    argument   count   =   4
    arguments size     = %2u DWORDs
    ASSERT       0x00010000
    AsyncTimerCallbackCompletion TimerInfo@%p
    Background
    BackgroundThread: 1
    BCL          0x40000000
    Blocking GC for Stack Overflow
    Boolean
    bp clr!EEStartup "g @$ra"
    callee-saved regs  = 
    Class System.Collections.Generic.IEnumerable`1<__Canon>
    CLASSLOADER  0x00000400
    Clock frequency  = %5.3f GHz
    Clock frequency  = 3.392 GHz
    CLR Owns
    CODESHARING  0x04000000
    CoInitialized
    Completion Port Thread
    CORDB        0x00000200
    CORPROF      0x00000800
    CurrentTotalLogChunk = %d
    CurrentTotalLogChunk = 9
    DBGALLOC     0x00002000
    Dead
    DeadThread:       0
    Debug Suspend Pending
    Debug Will Sync
    Detached
    double align       = %s  
    double align       = no
    ebp frame          = %s  
    ebp frame          = yes
    edit & continue    = no
    edit & continue    = yes
    EEClass: 03ef1698
    EEMEM        0x00000080
    EH           0x00004000
    ENC          0x00008000
    epilog        at   %04X
    epilog        at   002E
    epilog      end    = %s  
    epilog      end    = yes
    epilog      size   =   8
    epilog      size   = %2u 
    epilog     count   =   1
    epilog     count   = %2u 
    epilog #%2u    at   %04X
    exception handlers = no
    exception handlers = yes
    facilitiesToLog  = 0x%x
    facilitiesToLog  = 0xffffffff
    Failed to examine a HillClimbing log entry
    Failed to examine a WorkRequest
    Failed to Start
    Fields:
    Finalized
    Fully initialized
    fully interruptible= %s  
    fully interruptible=yes
    GC           0x00000001
    GC On Transitions
    GC Root %p RELOCATED %p -> %p  MT = %pT
    GC Suspend Pending
    GCALLOC      0x00000100
    GCHeap::Promote: Promote GC Root *%p = %p MT = %pT
    GCINFO       0x00000002
    GCROOTS      0x00080000
    GuardStack cookie  = [%s%u]
    Handles:
    Hijacked by the GC
    Hosted Runtime:   no
    IJW          0x00400000
    In Multi Threaded Apartment
    In Single Threaded Apartment
    INTEROP      0x00100000
    Interrupted
    Interruptible
    JIT          0x00000008
    Last message time  %S
    Last message time  15:26:56
    Legal to Join
    levelToLog       = %d
    levelToLog       = 6
    LOADER       0x00000010
    local alloc        = no
    localloc           = yes
    LOCALS:
    lock(MyObject)
    lock(r1)                             lock(r2)
    LOCKS        0x20000000
    MARSHALER    0x00200000
    MaxLogSizePerThread = 0x%x (%d)
    MaxLogSizePerThread = 0x10000 (65536)
    MaxTotalLogSize = 0x%x (%d)
    MaxTotalLogSize = 0x1000000 (16777216)
    METADATA     0x00000020
    method      size   = %04X
    method      size   = 0036
    MethodTable 03e40f4c
    MTA Interfaces to be released: 2
    Name: Value
    No thread states for '%s'.
    none  
    o = firstobject;
    PARAMETERS:
    PendingThread:    0
    perdomain - Break down the statistics by the app domain in which
    profiler callbacks = yes
    prolog      size   =  19
    prolog      size   = %2u 
    public A Test(IEnumerable<B> n)
    ReJITID %p: 
    REMOTING     0x00001000
    Reported Dead
    Resource r1 = new Resource();
    Resource r2 = new Resource();
    RuntimeCallableWrappers (RCW) to be cleaned:
    saved reg.  mask   = 000B
    SECURITY     0x10000000
    security check     = no
    security check obj = yes
    Size: 20(0x14) bytes
    SP       IP       Function
    STA Interfaces to be released: 1
    Stack Crawl Needed
    stack frame size   =   1
    stack frame size   = %2u DWORDs
    Start time         %S
    Start time         15:26:31
    STARTUP      0x01000000
    stat - Only display the statistics and not the list of handles and
    Statistics:
    STORE        0x08000000
    String
    STUBS        0x00000004
    Suspend Unstarted
    SYNC         0x00000040
    Sync region = [%u,%u]
    Sync Suspended
    Task Reset
    Thread Abort Requested
    Thread Pool Worker Thread
    ThreadCount:      2
    THREADPOOL   0x00040000
    ThreadsWithLogs  = %d
    ThreadsWithLogs  = 3
    Time Transition     New #Threads      #Samples   Throughput
    Total 19 objects
    Total elapsed time %5.3f sec
    Total elapsed time 25.077 sec
    type - A type of handle to filter it by.  The handle types are:
    Unable to read FullDllName address at %p
    Unable to read InMemoryOrderModuleList address at %p
    Unable to read PEB_LDR_DATA address at %p
    Unknown Function: %p  Context: %p
    Unstarted
    UnstartedThread:  0
    untracked count    =   5
    untracked count    = %2u 
    User Suspend Pending
    ValueClass System.RuntimeTypeHandle
    var ptr tab count  =   0
    var ptr tab count  = %2u 
    varargs            = no
    varargs            = yes
    VERIFIER     0x00020000
    Void
    void I1.M1()
    void IT1<U>.M1(U u)
    void M1();
    void M1(T t);
    while(o != endobject)
    Yield Requested
    ZAP          0x00800000
   !bpmd Demo.cs:15
   !CLRStack -i -a           : This will show you all parameters and locals for all frames
   !CLRStack -i -a 3         : This will show you all parameters and locals, for frame 3
   !CLRStack -i var1 0       : This will show you the fields of 'var1' for frame 0
   !CLRStack -i var1.[6] 0   : If 'var1' is an array, this will show you the element
   !CLRStack -i var1.[basetype] 0   : This will show you the fields of 'var1', and
   !CLRStack -i var1.abc 2   : This will show you the fields of 'var1', and expand
   !StopOnException can be used purely as a predicate in a larger expression.
   !StopOnException -create System.OutOfMemoryException 1
   !StopOnException System.OutOfMemoryException 3
   (%d elements)
   (1 element)
   (empty)
   1. On the stack
   2. Within a GC Handle
   3. In an object ready for finalization
   4. As a member of an object found in 1, 2 or 3 above.
   a) You have some version of .Net Framework installed on your machine. Any OS from
   and set up the breakpoint as a first-chance exception. -create2 would set
   and throws it.
   associated with any physical thread - this may happen when the host reuses
   at 
   At the debugger prompt, anytime after loading SOS, type:
   b) You have PDBs for the managed modules that need breakpoints, and your symbol
   called.
   current thread is a System.OutOfMemoryException. Otherwise, $t3 will be set
   display the special string "<<<<" when this internal thread object is not 
   for example, failure to expand the finalize queue when GC.ReRegisterForFinalize is
   for example, some .NET framework code converts a native OOM exception to managed 
   If you type:
   in which case you will see JIT_New* on the call stack because managed code called new.
   isn't loaded yet. What can I do?
   it up as a 2nd-chance exception. 
   maintaining the breakpoint. The -create parameter allows SOS to go ahead
   manually create such predicates, for example:
   such calls together to stop on various exception types. You'll have to 
   sxe -c "!soe System.OutOfMemoryException 3; 
   The pseudo-register number (1) indicates that SOS can use register $t1 for
   the runtime internal thread object)
   then register $t3 will be set to 1 if the last thrown exception on the 
   to 0. Using the Windows Debugger scripting language, you could chain 
  %8d
  %8x
  %s %S
  (%d)
  (Unhandled CorElementType: 0x%x)
  [E%s%02XH] a 
  + %S %s
  + (Error 0x%x printing local variable %d)
  + (Error 0x%x printing parameter %d)
  + (Error 0x%x retrieving local variable '%S')
  + (Error 0x%x retrieving parameter '%S')
  = '%C'
  = %d
  = %f
  = %hd
  = %hu
  = %I64d
  = %I64u
  = %s
  = %u
  = <function pointer 0x%x>
  = <pointer>
  = object
  -> %p %S%s
  0:000> !dumpil b741dc
  06808094(AAA.Test+b)
  1) If you have a System.Reflection.Emit.DynamicMethod object, just pass
  1) If you know the full path to SOS, use this command and skip to step 6
  2) If you don't know the full path to sos, its usually next to clr.dll
  2) If you have a DynamicMethodDesc pointer you can use that to print the
  238 001e40ec            3         1 001e4e60   e04   3   00a7a194 Resource
  239 001e4124            3         1 001e5980   ab8   4   00a7a1a4 Resource
  3) g
  3) If you have an ordinary MethodDesc, you can see the IL for that as well,
  4) If you have a pointer directly to the IL, specify /i followed by the
  4) You'll get the following notification from the debugger:
  5) Now you can load SOS. Type
  6) Add the breakpoint with command such as:
  7) g
  8) You will stop at the start of MyApp.Main. If you type "bl" you will 
  a515f4   14a740 5baf8d28 System.TypedReference
  a51608   14a740 5bb05764 System.Globalization.BaseInfoTable
  a51958   14a740 5bb05b24 System.Globalization.CultureInfo
  a51a44   14a740 5bb06298 System.Globalization.GlobalizationAssembly
  a51de0   14a740 5bb069c8 System.Globalization.TextInfo
  a56b98   14a740 5bb12d28 System.Security.Permissions.HostProtectionResource
  a56bbc   14a740 5baf7248 System.Int32
  a56bd0   14a740 5baf3fdc System.String
  a56cfc   14a740 5baf36a4 System.ValueType
  CacheEntryHeap:  
  DispatchHeap:    
  error getting thread %p, aborting this field
  Error!  integer overflow on numThread 0x%08x
  ID  (sec from start)
  If a token is unresolved, run "!do <addr>" on the addr given
  IL_0000: ldstr 70000002 "Inside invoked method "
  IL_0005: call 6000003 System.Console.WriteLine(System.String)
  IL_000a: ldc.i4.1
  IL_000b: newarr 2000004 "System.Int32"
  IL_0010: stloc.0
  IL_0011: ldloc.0
  IL_0012: ret
  in parenthesis. You can also look at the token table yourself, by
  IndcellHeap:     
  LookupHeap:      
  Module Name
 - on GC entry available commit space was %d MB
  or    !Name2EE module_name!item_name
  ResolveHeap:     
  running "!DumpArray 00b77388".
  This is dynamic IL. Exception info is not reported at this time.
 !"#$%&'()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~
 %c%s
 %c%s%c%x
---------------------------- %d total entries ------------------------------------
 %s %S
 %s:FailInit
 %s:NotInit 
 (%s)
 (%S)
 (%S, mdToken: %p)
 (<exec cmd="!DumpArray /d %p">Print Array</exec>)
 (BAD Method)
 (BAD MethodTable)
 (C:\pub\unittest.exe)
 (code for MD: %S)
 (CURRENT)
 (dependent handle)
 (Dynamic)
 (gcstress)
 (iargs=%02X)
 (interior)
 (iptr)
 (JitHelp: %s)
 (MD: %S)
 (MethodDesc: %Ix)
 (MT: %S)
 (nested exceptions)
 (NEUTERED)
 (Object: %S)
 (pinned)
 (READY to jit on next call)
 (reverted)
 (Shared Domain)
 (STRONG)
 (stub for %S)
 (System Domain)
 (Unknown function)
 (Unknown VTable)
 (WEAK)
 * Ctx[BSI]:  %08x  %08x  %08x    
 .NET Framework
 @ 0x%I64x
 [%s:%d]
 [ERROR: INVALID TOKEN 0x%8.8X] 
 [ERROR: Invalid token 0x%8.8X] 
 [ERROR: INVALID TOKEN TYPE 0x%8.8X] 
 [ERROR: Invalid TypeDef record 0x%8.8X] 
 [ERROR: Invalid TypeRef record 0x%8.8X] 
 [explicit]
 [hasThis]
 | %S
 |- %s
 |- %S %s
 |- %s = %S
 |- < unknown type > %S
 <no information>
 = "%S"
 = %S
 = null
 ====> Exception 
 030:0F0M0W0m0r0w0
 0x%p
---------------------------- 2407 total entries -----------------------------
 Address       MT     Size
 Address   Domain       MT Type Name
 argMask=%02X
 argOffs(%d) =
 Base Class Array'
 Base Class Descriptor at (
 Breakpoint index - Location, ModuleID, Method Token
 catch(%S) 
 Checked or debug build
 Class Hierarchy Descriptor'
 CLR 
 Complete Object Locator'
 CurrentLimit: %d
 delete
 delete[]
 dependentHandle="1"
 -details:            optional. Ask the command to print out details
 even though you aborted.
 Example output:
 exr@%p
 free
 Free
 Free: %d
 GCCount    Value       MT Promoted?                Notes
 GCCount   Object                                    Roots
 GCCount   Object                                  Message
 Idle: %d
----- Interrupted by user -----
 is not a MethodTable
 Jupiter 
------------ Last message from thread %x -----------
 -length <length>:    optional, only supported for single dimension array. 
 Low Bit(s) Set
 MaxFree: %d
 MaxLimit: %d
 mdToken: %08x (%ws)
 Microsoft Corporation.  All rights reserved.
 Microsoft Operations Puerto Rico1
 Microsoft Operations Puerto Rico1&0$
 MinLimit: %d
 new[]
----- No thread logs in the image: The stress log was probably not initialized correctly. -----
 -nofields:           optional, only takes effect when -details is used. Do
 null
 orphaned 
 Phh'
 pinned
 retail
 retail build
 Running: %d
 segment    begin allocated     size
 -start <startIndex>: optional, only supported for single dimension array. 
 SVW3
 ThinLock owner %x (%p) Recursive %x
 'this'
 total, 0x%I32x (%I32lu) bytes wasted
 Total: %d
 Type Descriptor'
 u0h0S
 XXX 
! 1 0x%p %zd
!]_0t
!_is_double
!0(0O0V0
!AnalyzeOOM
!AnalyzeOOM displays the info of the last OOM occured on an allocation request to
!BPMD [-nofuturemodule] <module name> <method name> [<il offset>]
!BPMD <source file name>:<line number>
!bpmd asks the Windows Debugger to receive CLR Notifications, and waits to
!bpmd bpmd.exe ExplicitItfImpl`1.IT1<U>.M1
!bpmd bpmd.exe NS.Outer+ExplicitItfImpl`1.NS.Outer.IT1<U>.M1
!bpmd bpmd.exe Outer+ExplicitItfImpl`1.Outer.IT1<U>.M1
!BPMD -clear <pending breakpoint number>
!BPMD -clear or !BPMD -clearall to remove pending breakpoints from the list.
!BPMD -clear, and !BPMD -clearall commands. !BPMD -list generates a list of 
!BPMD -clearall
!BPMD does not accept offsets nor parameters in the method name. You can add
!bpmd is not supported on a dump file.
!BPMD -list
!BPMD -md <MethodDesc>
!bpmd myapp.exe ExplicitItfImpl.I1.M1
!bpmd myapp.exe G1`1.G
!bpmd myapp.exe G3`3.F
!bpmd pending breakpoint list
!bpmd 'price, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null' Price.M2
!BPMD provides managed breakpoint support. If it can resolve the method name
!BPMD works equally well with generic types. Adding a breakpoint on a generic 
!CLRStack [-a] [-l] [-p] [-i] [variable name] [frame]
!CLRStack [-a] [-l] [-p] [-n]
!CLRStack, it is a good aid to determining the values of locals and 
!COMState
!COMState lists the com apartment model for each thread, as well as a Context 
!DumpArray 
!DumpAssembly <Assembly address>
!DumpCCW <CCW address or COM IP>
!DumpClass <EEClass address>
!DumpDomain [<Domain address>]
!DumpHeap [-stat] 
!DumpHeap is a powerful command that traverses the garbage collected heap, 
'!DumpHeap -live' and '!DumpHeap -dead' for that functionality.
!DumpIL <Managed DynamicMethod object> | 
!DumpIL prints the IL code associated with a managed method. We added this
!DumpLog [-addr <addressOfStressLog>] [<Filename>]
!DumpMD <MethodDesc address>
!DumpModule [-mt] <Module address>
!DumpModule on the Class, MethodTable and Module fields above.
!DumpModule on the fields listed to learn more.
!DumpMT [-MD] <MethodTable address>
!DumpObj [-nofields] <object address>
!DumpObj to obtain the CCW address corresponding to a managed object or pass
!DumpObj to obtain the RCW address corresponding to a managed object.
!DumpRCW <RCW address>
!DumpRuntimeTypes 
!DumpRuntimeTypes finds all System.RuntimeType objects in the gc heap and 
!DumpSig <sigaddr> <moduleaddr>
!DumpSig will also work with generics.  Here is the output for the following
!DumpSigElem <sigaddr> <moduleaddr>
!DumpSigElem will also work with generics.  Let a function be defined as follows:
!DumpStack [-EE] [-n] [top stack [bottom stack]]
!DumpStackObjects [-verify] [top stack [bottom stack]]
!DumpVC <MethodTable address> <Address>
!DumpVC allows you to examine the fields of a value class. In C#, this is a 
!DumpVC is quite a specialized function. Some managed programs make heavy use 
!EEHeap [-gc] [-loader]
!EEHeap enumerates process memory consumed by internal CLR data structures. You
!EEStack [-short] [-EE]
!EEVersion
!EHInfo (<MethodDesc address> | <Code address>)
!EHInfo shows the exception handling blocks in a jitted method. For each 
!FinalizeQueue [-detail] | [-allReady] [-short]
!FindAppDomain <Object address>
!FindAppDomain will attempt to resolve the AppDomain of an object. For example,
!FindRoots <obj>
!FindRoots -gen <N>
!FindRoots -gen <N> | -gen any | <object address>
!FindRoots -gen 1
!FindRoots is a diagnostic command that is meant to answer the following 
!FindRoots is not supported on a dump file.
!FindRoots to be able to identify roots for objects from the current condemned 
!GCHandleLeaks
!GCHandles [-type handletype] [-stat] [-perdomain]
!GCHandles provides statistics about GCHandles in the process.
!GCInfo (<MethodDesc address> | <Code address>)
!GCInfo is especially useful for CLR Devs who are trying to determine if there 
!gcroot %p, and if you find a root on a
!GCRoot [-nostacks] <Object address>
!GCRoot doesn't attempt to determine if a stack root it encountered is valid 
!GCRoot looks for references (or roots) to an object. These can exist in four
!GCWhere <object address>
!GCWhere displays the location in the GC heap of the argument passed in.
!HeapStat [-inclUnrooted | -iu]
!HistClear
!HistInit
!HistObj <obj_address>
!HistObjFind <obj_address>
!HistRoot <root>
!Impossible!
!IP2MD <Code address>
!ListNearObj <object address>
!ListNearObj is a diagnostic tool that displays the object preceeding and 
!MinidumpMode <0 or 1>
!Name2EE <module name> <type or method name>
!Name2EE <module name>!<type or method name>
!object <valid object pointer>
!ObjSearch <valid object pointer>
!ObjSize [<Object address>]
!ObjSize includes the size of all child objects in addition to the parent.
!PrintException [-nested] [-lines] [-ccw] [<Exception object address>] [<CCW pointer>]
!PrintException can display source information if available, by specifying the 
!PrintException prints the exception object corresponding to a given CCW pointer, 
!PrintException will notify you if there are any nested exceptions on the 
!ProcInfo [-env] [-time] [-mem]
!ProcInfo is not supported on a dump file.
!ProcInfo lists the environment variables for the process, kernel CPU time, as 
!RCWCleanupList [address]
!Root <valid object pointer>
!SaveModule <Base address> <Filename>
!StopOnException [-derived] 
!StopOnException helps when you want the Windows Debugger to stop on a 
!StopOnException.
!SyncBlk [-all | <syncblk number>]
!This program cannot be run in DOS mode.
!ThreadPool
!Threads [-live] [-special] 
!Threads command will also tell you which threads have nested exceptions.
!Threads lists all the mananaged threads in the process. 
!ThreadState value
!TkjE
!Token2EE <module name> <token>
!Token2EE among others.
!TraverseHeap [-xml] [-verify] <filename>
!TraverseHeap writes out a file in a format understood by the CLR Profiler. 
!U [-gcinfo] [-ehinfo] [-n] <MethodDesc address> | <Code address>
!VerifyHeap
!VerifyHeap is a diagnostic tool that checks the garbage collected heap for 
!VerifyObj <object address>
!VerifyObj is a diagnostic tool that checks the object that is passed as an 
!VMMap
!VMMap requires a full memory dump (.dump /ma) or a live process.
!VMMap traverses the virtual address space and lists the type of protection 
!VMStat
!VMStat requires a full memory dump (.dump /ma) or a live process.
"!DumpHeap -type Customer".
"!PrintException -nested".
"B <1=
"catch" blocks respectively.
"Free" objects are simply regions of space the garbage collector can use later.
"generations," wherein the youngest objects live in generation 0, and 
"I see that GCs are happening, however my objects have still not been 
"-nested" option to get full details on the nested exception objects. The
"Server" mode there is one dedicated garbage collector thread per CPU.
#.X'=
#0S0]0b0g0l0
#t>PhXb
$%s$%X
$0*0?0I0r0x0
%*.*d
%-*.*d
%*.*p
%-*.*p
%*.*s
%*.*S
%-*.*S
%-*.*s
%*.*x
%-*.*x
%-*s %-*s %-*s  %-13s %-13s %-8s %-8s
%*s.catch
%*s.finally
%*s.try
%*s} // end .catch
%*s} // end .finally
%*s} // end .try
%*sIL_%04x: 
%02X 
%08lx
%08x 
%08x is a safepoint: 
%08x%s interruptible
%11d 
%20.20S 
%20.20s 
%-20s 
%20s: %d
%30s: %d
%-30s: %d
%3d %4x %p
%4x %13.9f : 
%-7s  %*s  %*s  %*s %*s  %*s
%-7s %*sK %*sK %*sK %*s %*sK
%8.2lf %-14s %12d  %12d  %11.2lf
%8d %12I64u "%S"
%8d %8d %8d
%8d %p 
%8d %p %p %9s 
%8p %8p %8p %8p
%8p %8p %8p %9s
%8s   %8s %s
%8s  %8s  %8s  %8s
%-8s %12s %12s %12s %12s
%8s %12s %s
%8s %8s
%8s %8s %12s %s
%8s %8s %16s
%8s %8s %40s
%8s %8s %8s
%8s %8s %8s %20s %2s %8s %8s %s
%8s %8s %8s %8s
%8s %8s %8s %9s %20s
%8s %8s %8s Apartment
%8s %8s %8s Type
%8s %8s %8s Type Name              
%8s %8s %s
%-8s %-8s %s
%8s %8s Type
%-8s %s 
%d - %ws!%ws+%d, 0x%p, 0x%08x
%d - %ws, %ws, %p
%d - %ws:%d, 0x%p, 0x%08x
%d.%d
%d.%d.%d
%I64d
%I64u
%ld percent of memory is in use.
%p   %d     %2d     %p   %p   %p    0x%x(%d)
%p  %p  %p  0x%I32x(%I32d)
%p %6.1fMB         %p %S
%p %p 
%p %p %p
%p %p %s %S
%p %S
%p %s 
%p %s %S
%p %s [NativeStackFrame]
%p is not a MethodDesc
%p is not a Module or base address
%p is not a valid MethodDesc
%p is not a valid object
%p is not a valid object.
%p-%p %p  %-13s %-13s %-8s %-8s
%p(%x:%x) 
%p:%p
%s    
%s %8d %12I64u 
%s %8x %8x 
%S %s %12d (0x%x)
%s %s %8d
%s %s %8d%s
%s (MethodDesc %s %S)
%s @ %d:
%s 0x%08x %S
%s is not IP
%S#[k
%s%s pointer
%s, please contact PSS
%s.[%d]
%s.dll
%s: "%s"
%S::%S
%S::%S 
%s_%s.dll
%s_%s_%s_%u.%u.%u.%02u%s.dll
%u sections in file
%u.%u.%u.%u
%x "%S"
%x %S
%x (%p)
&amp;
&apos;
&quot;
&S|9a
( 8PX
(#Could not read address of string#)
(%p->%p)
(%S[])
(<CLR reg>) 
(0/0^0e0
(010:0H0Q0s0z0
(0x%p) 
(0x%p, 0x%p)
('8PW
(duplicate)
(DWORD) LogFacility = 0xffffffbf (this is a bit mask, almost all logging is on.
(DWORD) LogLevel = 6             (this is the default value if the key isn't
(DWORD) StressLog = 1
(DWORD) StressLogSize = 65536    (this is the default value if the key isn't
(fd0.ec4): CLR notification exception - code e0444143 (first chance)
(for one thing, custom dump commands can map in additional memory, but there 
(FreeThreaded)
(g9SOS does not support the current target architecture (%x).
(GC) 
(GENERIC_PARAM_CONTEXT_METHODDESC)
(GENERIC_PARAM_CONTEXT_METHODHANDLE)
(GENERIC_PARAM_CONTEXT_THIS)
(if your program is myapp.exe) in the same directory. Put the following lines
(interior)
(MethodDesc %s 
(MethodTable: %Ix)
(MTA)
(note that the fully qualified type name for ExplicitItfImpl became
(null)
(obtained with ".dump /ma <filename>" in the Windows Debugger) is often the 
(pinned)
(STA)
(this is an oversimplification, see NOTE below). If another thread tries to 
(Threadpool Completion Port) 
(Threadpool Worker) 
(threads 3 and 4 have similar output)  
(TransitionMU)
(TransitionUM)
(Unhandled CorElementType: 0x%x)
(untracked)
)Microsoft Root Certificate Authority 20100
)Microsoft Root Certificate Authority 20110
)Ph,i
*(...)
*?*kXIc
*0A0V0`0y0
*3_5g5
, calling 
, continuing...
, Pegged by
,JrOdk
.................
.....................................
...<etc>...
.?AVbad_alloc@std@@
.?AVbad_array_new_length@std@@
.?AVbad_exception@std@@
.?AVDataRead@sos@@
.?AVException@sos@@
.?AVexception@std@@
.?AVHeapCorruption@sos@@
.?AVlength_error@std@@
.?AVlogic_error@std@@
.?AVout_of_range@std@@
.?AVtype_info@@
.00cfg
.050l0
.CRT$XCA
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIC
.CRT$XIZ
.CRT$XLA
.CRT$XLZ
.CRT$XPA
.CRT$XPX
.CRT$XPXA
.CRT$XPZ
.CRT$XTA
.CRT$XTZ
.data
.data$r
.data$rs
.edata
.gfids
.idata
.idata$2
.idata$3
.idata$4
.idata$5
.idata$6
.lines or .symopt commands), and if symbols are available for the managed
.lines or .symopt commands), SOS will look up the symbols for every managed 
.loadby shortcut). Within the Microsoft corpnet, we keep tagged versions 
.rdata
.rdata$r
.rdata$sxdata
.rdata$T
.rdata$voltmd
.rdata$zzzdbg
.rsrc$01
.rsrc$02
.rtc$IAA
.rtc$IZZ
.rtc$TAA
.rtc$TZZ
.text
.text$di
.text$mn
.text$mn$00
.text$x
.text$yd
.tls$
.tls$ZZZ
.xdata$x
/* UNKNOWN TYPE (0x%X)*/
// static method
// this method's name is 'I1.M1'
// this method's name is 'IT1<U>.M1'
/f clr.dll
/f mscoree.dll
: :%:_:d:~:
: :(:0:8:@:H:P:X:`:h:p:x:
: :=:J:h:
: :4:D:L:`:h:
: ;&;;;E;n;t;
: ;&;L;p;
: ;D;H;L;P;T;X;\;`;d;h;l;p;t;x;|;
: ;J;R;o;
:!;';<;F;o;u;
:":(:-:::@:S:X:e:k:~:
:":N:U:j:u:
:";*;3;<;E;
:#:*:@:W:
:#:z:
:$:*:c:i:{:
:$:,:4:<:D:L:T:\:d:l:t:|:
:$:,:4:<:H:h:p:x:
:$:+:1:S:g:x:
:$:4:D:T:d:t:
:$;/;:;@;I;
:%:#;2;
:%:q:
:%:R:^:l:|:
:%;@;G;`;
:&:2:\:}:
:&:4:B:M:V:_:k:
:&;8;
:(:N:b:
:):M:
:*:7:N:
:*;^;o;
:,:<:L:\:l:|:
:,:O:Z:k:y:
:.:B:L:V:l:
:.:J:U:
:.;5;
:.;8;=;B;G;
:/:6:L:S:c:
:/:N:u:
:/;5;
:/;6;S;Z;p;
:::D:d:
:::J:]:b:r:|:
:-:;:R:Y:c:
:;:x:
:';?;`<
:';J;
:+:F:W:c:
:<:D:P:p:x:
:>:i:t:
:0:@:S:d:
:0:8:@:H:P:X:d:
:0:8:@:H:T:x:
:0;f;
:3:e:w:~:
:3:X:
:3;a;
:5:U:u:~:
:5;n;
:6;H;
:7:T:j:
:7;e;M<r<|<
:9:J:
:9:X:t:
:9;P;
:A:q:
:B:P:
:D:4;
:D:K:
:D:S:\:r:
:f;v;
:F;X;
:H:y:
:J;r;
:L:r:
:O;m;
:P:V:k:u:
:Q:w:
:r;{;
:U:d:m:u:
:U;\;
:V:c:
:V;h;
:W:b:
; ;$;(;,;0;4;8;<;@;D;H;v;
; ;(;
; ;(;0;8;@;H;P;X;`;h;p;x;
; ;(;0;8;D;d;l;t;|;
; ;:;F;];~;
; ;@;H;P;\;|;
; ;@;L;l;x;
; ;1;C;T;v;
; <T<\<u<
;!</<;<T<g<n<
;";,;U;[;o;
;";';.;I;X;_;f;l;
;";+;C;P;
;";I;w;
;"<6<H<}<
;$;,;4;<;D;L;T;\;d;l;t;|;
;$;,;8;X;`;l;
;$;/;f;
;$;0;P;X;`;l;
;$;4;D;T;d;t;
;%;*;/;4;9;r;~;
;%;4;O;
;%;4;P;a;
;%;B;
;&<;<t<z<
;&<5<
;(;a;g;|;
;*;/;4;O;\;e;j;o;
;*<:<
;*<_<f<
;,;<;
;.;^;
;.;4;d;k;
;.;4;G;L;X;s;
;.<4<I<S<|<
;;;B;];d;};
;';`;f;{;
;;<A<V<`<
;;<B<
;-;4;
;?<f<
;[<q<
;^@sKj
;^0r'SV
;^8rW;~DwRr
;_<y<
;+;^;i;p;
;<<@<D<H<L<P<T<X<
;<<{<
;<<p<w<+=I=w=
;0;;;
;0;E;O;Y;z;
;3;j;
;6;M;s;
;7;?;Q;^;
;A,w1r
;B<N<\<l<x<
;D;{;
;d<o<
;E<L<i<p<
;F@t3
;GLs,
;GLu`
;J<Q<w<
;N;U;k;
;OHuh
;Q(s*
;Q<X<u<|<
;R;s;~;
;V;h;
;V<b<
;W;R<
;w0r8
;Wdt 3
? ?(?4?X?x?
?#?K?c?
?$?,?4?<?D?L?T?\?d?l?t?|?
?$?+?`?
?$?2?d?
?$?4?D?T?d?t?
?%?A?`?r?
?%?f?p?
?%?M?d?
?&?B?X?t?
?&?K?Y?
?(?a?g?|?
?(?A?i?p?
?(?D?}?
?(?H?P?X?`?h?p?x?
?*?i?
?,?4?H?T?\?t?|?
?/?4?I?P?h?
?;?A?`?g?m?
???]?
???F?\?
?'?3?_?
?'?S?t?
?-?W?
?\?j?
?]tfS
?+?K?z?
?0?C?]?p?
?1?T?{?
?4?;?V?]?v?
?4?@?`?l?
?4?H?R?Y?s?z?
?5?;?I?Y?_?o?
?5Wg4p
?6?H?
?7?D?Q?a?}?
?9???M?S?f?l?
?A?[?e?j?o?t?~?
?AqGO
?B?I?S?b?o?
?B?l?r?
?D?Z?
?E?Q?_?o?
?H?l?
?L?S?p?w?
?M?f?
?P?W?^?e?
?V?e?
@.reloc
@.rsrc
@_^[]
@7H7P7X7`7h7p7x7
@b;zO]
@gcLe
[%s: %p]
[%S: p] 
[%s]%35s: %d
[.NET Framework Debugging Control]
[0b0x0
[2] 00ad28f0
[3] 00ad28fc
[4] 00ad2908
[4RPQ
[aOni*{
[BAD: RANK == 0!]
[basetype]
[DEFAULT]
[-details]
[ERROR! NIL TOKEN]
[explicit] 
[FASTCALL]
[FIELD]
[hasThis] 
[IL Stub or LCG]
[info per heap]
[InvalidReference]
[-length <length>]
[LOCALSIG]
[-nofields]
[PROPERTY]
[PRPQ
[RuntimeUnwindableFrame]
[-start <startIndex>]
[STDCALL]
[THISCALL]
[UNMANAGED]
[VARARG]
[x86 and x64 documentation]
\$@t$
\\ <these are two backslashes, immediately followed by a newline>
\0e0k0y0
\SVW3
\SVWjX
] argMask=%02X
] cur = 00000000
] ptrArgs=[
^$+^8+
^<V7w
^4SWhl
_ 7Zj
_[hh!
_^][3
_^][Y
__based(
__Canon
__cdecl
__clrcall
__crt_strtox::floating_point_value::as_double
__crt_strtox::floating_point_value::as_float
__eabi
__fastcall
__pascal
__ptr64
__restrict
__stdcall
__swift_1
__swift_2
__thiscall
__unaligned
__vectorcall
_<;_<tH
_cabs
_EFN_GetManagedExcepStack
_EFN_GetManagedExcepStack(%P, wszStr, sizeof(wszStr)) returned:
_EFN_GetManagedExcepStack(NULL, wszStr, sizeof(wszStr)) returned:
_EFN_GetManagedExcepStackW
_EFN_GetManagedObjectFieldInfo
_EFN_GetManagedObjectName
_EFN_StackTrace
_HResult
_hypot
_innerException
_is_double
_items
_logb
_message
_nextafter
_remoteStackTraceString
_RTL_USER_PROCESS_PARAMETERS
_stackTrace
_stackTraceString
_xcode
`.data
`_o=8u
`0^0\
`ALL`
`anonymous namespace'
`copy constructor closure'
`default constructor closure'
`dynamic atexit destructor for '
`dynamic initializer for '
`eh vector constructor iterator'
`eh vector copy constructor iterator'
`eh vector destructor iterator'
`eh vector vbase constructor iterator'
`eh vector vbase copy constructor iterator'
`h````
`h`hhh
`lfuFu
`local static guard'
`local static thread guard'
`local vftable'
`local vftable constructor closure'
`managed vector constructor iterator'
`managed vector copy constructor iterator'
`managed vector destructor iterator'
`omni callsig'
`placement delete closure'
`placement delete[] closure'
`RTTI
`scalar deleting destructor'
`SOS: warning, optimizations for this module could not be suppressed because this CLR version doesn't support the functionality
`string'
`typeof'
`udt returning'
`vbase destructor'
`vbtable'
`vcall'
`vector constructor iterator'
`vector copy constructor iterator'
`vector deleting destructor'
`vector destructor iterator'
`vector vbase constructor iterator'
`vector vbase copy constructor iterator'
`vftable'
`virtual displacement map'
{ ... }
{ =========== BEGINGC %d, (requested generation = %lu, collect_classes = %lu) ==========
{36PrM
{ByRef, ByRef}
{ByRef, Object}
{Object, ByRef}
{Object, Object}
{Scalar, ByRef}
{Scalar, Object}
|$ < u
~ $s%r
~$+~8+
~~~~           ~~~~~~~        ~~~~~~~        ~~~~~~~  ~~~~~~~~~          ~~~~~
~~~~~
~~~~~~~
~~~~~~~~~
~0WPQ
+%#llx
+%#x 
+>WWh80
+D$$Ph
< <(<0<<<`<
< <(<0<8<@<H<P<X<`<h<p<x<
< <.<><Z<|<
< t1<
<!<6<@<i<o<
<!<A<L<X<\<`<d<h<l<p<t<x<|<
<!=(=f=m=
<!=[=
<!='=<=F=o=u=
<#<(<9<
<#<,<9<O<
<#<D<T<l<
<#<f<x<
<$<,<4<<<D<L<T<\<d<l<t<|<
<$<0<P<\<|<
<$<2<;<[<p<v<
<$<4<D<T<d<t<
<$<Q<x<
<$<V<\<
<%<H<V<]<g<
<%<P<h<
<&<+<0<5<:<U<a<o<
<&<3<Q<X<
<&<8<K=R=
<&=2=f=t=
<&=8=j=q=
<(<:<G<p<
<(<H<P<X<`<h<p<x<
<(=/=S=_=m=}=
<(=2=i=
<)<3<E<O<Y<c<m<
<)<4<I<S<c<
<,<4<;<@<G<L<Y<n<z<
<,<8<@<\<|<
<.<9<P<b<r<
</<:<E<q<
</<[<f<l<
</<5<e<l<
</<5<I<p<z<
</gcheap>
</object>
</objects>
</roots>
</types>
<:<A<m<z<
<[<o<
<\<v<
<]=z=
<`<g<m<z<
<+=5=L=y=
<<<< 
<'<2<7<H<P<a<q<w<
<><N<j<
<0<[<b<}<
<0<<<\<h<
<1@1D1
<1=i=
<2<J<
<3=H=_=
<5=A=N=r=
<6<@<
<6=R=n=
<7<><c<
<7<H<\<f<
<8<L<[<i<
<A<H<r?
<a=u=
<aborted>
<After the Statistics section>
<array object address>
<B<N<\<h<~<
<CLR reg> 
<CLSID>
<descriptive text of the command>
<E=K=`=j=
<ELEMENT_TYPE_SENTINEL> 
<Error getting MethodDesc information>
<error getting slot 
<error>
<example output>
<exec cmd="!ClrStack -i %S %d">%S</exec>
<exec cmd="!DumpAssembly /d %s">%s</exec>
<exec cmd="!DumpCCW /d %s">%s</exec>
<exec cmd="!DumpClass /d %s">%s</exec>
<exec cmd="!DumpDomain /d %s">%s</exec>
<exec cmd="!DumpHeap /d -mt %s">%s</exec>
<exec cmd="!DumpMD /d %s">%s</exec>
<exec cmd="!DumpModule /d %s">%s</exec>
<exec cmd="!DumpMT /d %s">%s</exec>
<exec cmd="!DumpObj /d %s">%s</exec>
<exec cmd="!DumpRCW /d %s">%s</exec>
<exec cmd="!DumpVC /d %s %s">%s</exec>
<exec cmd="!gcroot /d %p">!gcroot %p</exec>, and if you find a root on a
<exec cmd="!ListNearObj /d %s">%s</exec>
<exec cmd="!PrintException /d %s">%s</exec>
<exec cmd="!ThreadState %s">%s</exec>
<exec cmd="!U /d %s">%s</exec>
<exec cmd="%s %x L%x">Content</exec>:     
<exec cmd="~~[%s]s">%s</exec>
<F=[=
<free>
<gcheap>
<heap traverse interrupted>
<heap walk interrupted>
<I<n<
<Illegal>
<integer overflow>
<integer underflow>
<interrupted>
<invalid MethodTable of inner exception>
<invalid MethodTable>
<invalid module token>
<invalid object: '%s'>
<Invalid Object>
<Invalid Object> (
<Invalid record>
<J=W=
<module name> can also be the debugger's name for a module, such as
<no data>
<no information>
<none>
<Not Available>
<Note: this object has an invalid CLASS field>
<object address="0x%p" typeid="%zd" size="%zd">
<objects>
<optional comments>
<repeat the sequence above>
<root kind="%S" address="0x%p"/>
<roots>
<String is invalid or too large to print>
<-t}</ty
<T<`<n<~<
<type id="%zd" name="%S"/>
<types>
<unable to retrieve data>
<unknown field def>
<unknown member ref>
<unknown method def>
<unknown method>
<unknown register>
<unknown token type %08x>
<unknown token type (token=%08x)>
<unknown type def>
<unknown type ref>
<unknown type spec>
<unknown type token>
<unknown type>
<unknown>
<Unloaded Type>
<user aborted>
<v=}=
<xt"<Xt
= ?$?(?,?0?4?8?<?@?D?H?L?P?T?X?\?`?d?h?l?
= =$=(=,=0=4=8=<=@=D=H=L=P=\=d=l=t=|=
= =$=(=,=0=4=8=<=@=D=H=L=P=T=X=\=`=d=h=l=p=t=x=|=
= =(=0=8=@=H=P=X=`=h=p=x=
= =,=T=x=
= =8=D=H=L=h=l=
= >'>K>
= 00D071F0 used 00D09254 committed 00D17000
=!=3=?=D=]=~=
=!=3=Z=~=
=!>'><>F>a>k>
=!>'><>F>o>u>
="=r=
="=U=[=
="=X=g=q=
=">*>]>g>u>
=#=C=f=s=
=$=,=4=@=`=h=p=|=
=$=,=4=<=
=$=1=7=\=j=~=
=$=4=D=T=d=t=
=%=,=
=%=1=V=
=&=,=L=Y=j=q=
=&>_>
=(=0=<=\=h=
=(=9=E=S=Z=
=(=h=n=
=(=V=h=n=
=)=9=K=P=a=h=v=
=,=8=P=
=,>N>z>
=.=J=\=u=
=/=H=`=
=:=A=Z=a=u=
=:=V=n=
=?=F=\=~=
=?=g=
=_=f=
=+>9>V>k>
=<=D=L=T=\=h=
=======================================
=============================================================================
='=1=:=K=]=x=
='=6=}=
=-=P={=
=-=Z=
=>>J>X>d>
=>>t>{>
=->z>R?
=0=G=N=
=1=?=S=W=a=e=n=
=1=S=
=2=8=R=o=y=
=2=P=b=}=
=4=;>V>h>
=6=c=m=w=
=6=e=v=
=6>H>
=7>a>
=8=?=U=v=
=8=D=h=
=8=S=
=8>?>
=9>O>
=B=k=v=
=b>k>
=D=K=[=`=
=F>[>f>
=f>x>
=G=M=w=}=
=G>q>"?s?x?
=H=e=y=
=I=Z=
=l=t=8>W>b>z>
=Q=i=
=S>_>k>
=T=j=y=
=X=5><>B>O>
=X=f=&>8>r>~>
=Y=_=
=Y>w>
> >$>(>,>0>4>8><>@>D>H>L>P>T>X>\>f>u>
> >(>0>8>@>H>P>X>
> >@>L>l>x>
> >->T>r>
> >D>K>f>
>!>1>A>K>
>!>A>X>_>u>
>!>B>I>d>k>
>"?*?8?D?P?[?
>#>:>
>#>@>G>]>
>$>,>4><>D>L>T>
>$>/>O>Z>e>
>$>->6>J>U>Z>_>v>
>$>2>|>
>$>4>D>T>d>t>
>$>W>y>
>%>*>=>Q>n>
>%>6>G>N>[>`>x>
>&?8?p?
>&?N?v?
>&?z?
>&>;>}>
>&>N>
>&>O>U>i>
>&>Y>
>(>.>G>M>_>e>
>(>0>8>@>H>P>X>`>h>p>x>
>(>0>8>@>H>P>X>`>l>
>(>H>P>X>`>h>p>x>
>)>/>B>H>k>q>
>)>5>=>e>
>)>8>L>
>,?i?
>.>3>J>h>
>'???W?o?
>'?8?R?c?z?
>-?9?E?
>'?j?q?
>@s5f
>^?tD
>_?z?
><?e?
>=>S>^>
>=umF8
>> Does SOS support DML?
>> I got the following error message. Now what?
>> I have a chicken and egg problem. I want to use SOS commands, but the CLR
>> I have a partial memory minidump, and !DumpObj doesn't work. Why?
>> What other tools can I use to find my bug?
>> Where can I get the right version of SOS for my build?
>>> %s:%d
>>> 001b00c1 90              nop
>'>2>@>G>U>
>'>2>=>`>|>
>->3>a>g>
>0>7>P>v>
>0>8>@>L>l>x>
>1?:?@?Q?]?b?
>1>6>X>\>`>d>h>l>p>t>x>|>
>1>8>^>
>2?Q?z?
>2>9>`>g>
>3>[>
>4???
>4>^>z>
>4>c?
>5>;>O>V>e>
>5>>>Q>[>
>6?D?U?\?n?
>6?E?
>6?F?p?
>6>v>
>8???n?u?
>8>R>x>
>9>H>g>r>
>A>e>
>a>g>
>A>i>
>A>j>
>b>:?T?
>B>Y>~>
>D>W>^>i>p>~>
>g>y>
>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0
>M>T>F?X?
>n?u?
>NGdx
>Q?j?z?
>q?x?
>R>^>l>|>
>s?|?
>U?^?l?w?
>V<4q
>Z>v>
0 0$0(0,0@0D0H0
0 0$0(0,0004080<0@0D0H0L0P0T0X0\0`0d0h0
0 if the field contains a pointer to another object. For valuetypes, you can 
0!0<0
0!010@0W0b0{0
0!0C0H0v0
0!0M0S0e0
0"0(0:0I0Q0Z0g0q0w0
0"1(191S1`1~1
0#0E0b0
0#0G0a0q0
0$0,040<0D0P0p0x0
0$040D0T0d0t0
0$0D0L0p0|0
0$0D0L0X0x0
0$1(1,1014181<1@1
0$1+1f1m1
0%0A0w0
0&0O0w0
0&242F3T3 4'4
0(020<0F0\0f0
0(020o0
0(030
0(040T0`0
0(0o0
0)000~0
0)0O0f0]1
0*1=1W1^1j1
0*101r1x1
0*111X1_1
0,080@0X0`0h0x0
0,0F0[0|0
0,0O0V0|0
0.080a0g0x0
0.0R0p0{0
0.151
0.mod
0/0:0J0Y0i0
0/0G0g0
0/0Z0a0|0
0:000>
0:000> !do a79d40
0:000> !dumparray -start 2 -length 3 -details 00ad28d0 
0:000> !dumpassembly 1ca248
0:000> !dumpheap
0:000> !dumpheap 1a71000 1a75000
0:000> !dumpheap -stat
0:000> !DumpLog
0:000> !dumpmd 902f40
0:000> !DumpModule 1caa50
0:000> !dumpmodule -mt 1aa580
0:000> !DumpObj a79d40
0:000> !DumpObj a79d98
0:000> !DumpStackObjects
0:000> !DumpVC 0090320c 00a79d9c
0:000> !eeheap -gc
0:000> !EEHeap -loader
0:000> !ehinfo 33bbd3a
0:000> !finalizequeue
0:000> !findappdomain 00a79d98
0:000> !gcinfo 5b68dbb8   (5b68dbb8 is the start of a JITTED method)
0:000> !IP2MD 03ef01a6
0:000> !name2ee unittest!MainClass
0:000> !name2ee unittest.exe MainClass.Main
0:000> !ObjSize a79d40
0:000> !SaveModule 5d1d0000 c:\pub\out.tmp
0:000> !token2ee image00400000 02000004
0:000> !token2ee unittest.exe 02000003
0:000> !VerifyHeap
0:000> !VMMap
0:000> !VMStat
0:000> .loadby sos clr
0:000> dd 15bc90 15bca0-4
0:000> dd 3ec0010
0:000> ed a79d40+4 01  (change the name field to the bogus pointer value 1)
0:000> K
0:000> lm
0:001> !HistInit
0:002> !findroots 06808094 
0:002> !GCWhere 02800038  
0:002> !GCWhere 0280003c
0:002> !heapstat
0:002> !heapstat -inclUnrooted
0:002> !ListNearObj 028000ec
0:002> !ListNearObj 028000f0
0:002> !lno 028000ec
0:002> !verifyobj 028000ec
0:002> !verifyobj 0680017c 
0:003> !HistClear
0:003> !HistObj 028970d4 
0:003> !HistObjFind 028970d4 
0:003> !HistRoot 01e411b8 
0:003> !syncblk
0:003> k
0:011> !ao
0:044> !name2ee price Price
0:0O0d0
0:1p1
0;0X0e0
0;1B1
0?1c1l2
0+090K0Z0r0
0+1=2D2
0+141v1
0>1E1_1}1
0-0>0L0Y0g0x0
00000000-0000ffff 00010000                NA            Free
00010000-00011fff 00002000  RdWr          RdWr          Commit   Private
00012000-0001ffff 0000e000                NA            Free
00020000-00020fff 00001000  RdWr          RdWr          Commit   Private
00021000-0002ffff 0000f000                NA            Free
00030000-00030fff 00001000  RdWr                        Reserve  Private
000G0|0
0012ea04 5d512f59 clr!CallDescrWorkerInternal+0x30
0012ee34 5d7946aa clr!CallDescrWorker+0x109
0015bc90  00a743f4 00a79f00 00a7b3d8 00a7b47c
0015cde8        6     10260      Free
0019fe48        2      6128      Free
001b00b0 8b0d3020ab03    mov     ecx,dword ptr ds:[3AB2030h] ("Break in debugger. When done type <Enter> to continue: ")
001b00b6 e8d5355951      call    mscorlib_ni+0x8b3690 (51743690) (System.Console.Write(System.String), mdToken: 0600091b)
001b00bb 90              nop
001b00bc e863cdc651      call    mscorlib_ni+0xf8ce24 (51e1ce24) (System.Console.ReadLine(), mdToken: 060008f6)
001caa50 C:\pub\unittest.exe
00400000 00408000   image00400000     (deferred)
0'070v0
0090320c  4000001        0                CLASS   instance 00a743d8 signature
0090320c  4000002        8         System.Int32   instance     2345 m1
0090320c  4000003       10       System.Boolean   instance        1 b1
0090320c  4000004        c         System.Int32   instance     1234 m2
0090320c  4000005        4                CLASS   instance 00a79d98 backpointer
0090320c  4000010        4            VALUETYPE   instance 00a79d9c m_valuetype
009032d8  400000f        4                CLASS     static 00a79d54 m_sExcep
009038ec  4000008        4                CLASS   instance 00a79ce4 name
009038ec  4000008        4             Customer   0 instance 00a79ce4 name
009038ec  4000009        8                 Bank   0 instance 00a79d2c bank
009038ec  4000009        8                CLASS   instance 00a79d2c bank
009038ec  400000a        c       System.Boolean   instance        1 valid
00a70000 00a71000  00a7e01c 0000d01c(53276)
00a70000 00a71000  010443a8 005d33a8(6108072)
00a71000 0015cde8       12 Free
00a7100c 0015cde8       12 Free
00a71018 0015cde8       12 Free
00a71024 5ba58328       68
00a71068 5ba58380       68
00a710ac 5ba58430       68
00a710f0 5ba5dba4       68
00a780c0    1.5MB    00bec800 System.Byte[]
00a79c78 03ef01a6 image00400000!Mainy.Level(Int32)+0xb
00a79c78 03ef02ab image00400000!Mainy.Top()+0xb
00a79c78 5d3725a1 image00400000!Mainy.Main()+0xee
00a7a1a4. Combine that information with the call stacks of the deadlock:
00da4e38    1.2MB    00ed2c00 System.Byte[]
00f16df0    1.2MB    01044338 System.Byte[]
010Y0e0w0
01a70000 01a71000  01a75000 0x00004000(16384)
01a70000 01a71000  01a76000 0x00005000(20480)
01a71000 5ba88bd8     2064
01a71810 0019fe48     2032 Free
01a72000 5ba88bd8     4096
01a73000 0019fe48     4096 Free
01a74000 5ba88bd8     4096
'02070?0c0
02080K0Q0g0m0w0
02800038 2    0   02800000 02800038 0282b740  12
0280003c 2    0   02800000 02800038 0282b740  0
030b5cb0 0x01000002 System.Object
030b6420 0x01000001 System.ValueType
030d115c 0x02000002 Funny
030d1228 0x02000003 Mainy
030fceb4 0x01000003 System.Exception
03167a50 0x0100000e System.Runtime.InteropServices.GCHandle
0334e374 0x0100000c System.Console
0336a048 0x0100000f System.GC
03ec0010  00000000 00000000 0090320c 0090375c
03ec0020  009038ec ...
03ef015d b901000000       mov     ecx,0x1
03ef0162 ff156477a25b     call   dword ptr [mscorlib_dll+0x3c7764 (5ba27764)] (System.Console.InitializeStdOutError(Boolean), mdToken: 06000713)
03ef0168 a17c20a701       mov     eax,[01a7207c] (Object: SyncTextWriter)
03ef016d 89442414         mov     [esp+0x14],eax
0404ea04 77f5c524 SharedUserData!SystemCallStub+0x4
0404ea08 77e75ee0 ntdll!NtWaitForMultipleObjects+0xc
0404eaa4 5d9de9d6 KERNEL32!WaitForMultipleObjectsEx+0x12c
0404eb38 5d9def80 clr!Thread::DoAppropriateAptStateWait+0x156
0404ecc4 5d9dd8bb clr!Thread::DoAppropriateWaitWorker+0x360
0404ed20 5da628dd clr!Thread::DoAppropriateWait+0xbb
0404ede4 5da4e2e2 clr!CLREvent::Wait+0x29d
0404ee70 5da4dd41 clr!AwareLock::EnterEpilog+0x132
0404ef34 5da4efa3 clr!AwareLock::Enter+0x2c1
0404f09c 5d767880 clr!AwareLock::Contention+0x483
0404f1c4 03f00229 clr!JITutil_MonContention+0x2c0
0404f1f4 5b6ef077 image00400000!Worker.Work()+0x79
040904B0
040n0u0
040U0
050e0
060H0
061G1
070_0
071}1
08             |             [EBP+08H] an untracked  local
090e0u0
090O0e0m0
090y0
090Y0f0
0C             |             [EBP+0CH] an untracked  local
0c1w1
0E             | 002D        reg ECX becoming dead
0F0S061H1
0f0u0
0F0U0
0F0X0
0G0Y0`0g0n0u0|0
0H0v0
0I0U0m0
0k0l1|1
0N0\0q0x0
0O0{0
0O0j0|2
0P<T<X<\<`<d<h<l<p<t<x<|<
0SVW3
0Unable to load '%S'.  HRESULT = 0x%x.
0V0]0l0
0W1f1s1
0x%*.*x
0x%-*.*x
0x%p 
0Z0m0w0
1 1$1(1,1014181<1D1T1d1t1
1 1&101;1E1K1U1`1j1p1z1
1 1&171=1
1 1(141T1\1h1
1 1(141X1x1
1 1,1L1T1\1d1p1
1 even if the thrown exception type doesn't exactly match the exception type
1!1l1
1!292W2
1"1W1]1
1"212H2N2T2Z2`2f2l2
1#191
1#232T2p2u2|2
1#IND
1#INF
1#QNAN
1#SNAN
1$1+161=1L1_1f1o1v1
1$141D1T1d1t1
1%1B1I1_1v1
1%1U1}1
1&1?1^1e1
1&101
1&1H1v1
1&282O2
1&282Y2y2
1&383s3
1(0&0
1(1S1
1(202
1) allocation request to GC heap 
1) The debugger shorthand ID (When the runtime is hosted this column might 
1) The thread has taken a lock.
1) When you just want to stop on one particular CLR exception
1)1:1H1Q1y1
1)1D1]1z1
1)2/2P2`2
1*181<1@1D1H1L1P1T1X1\1`1d1h1l1
1*2O3a3
1,;0;
1,1<1d1
1. Find out the generation of the object of interest using the !GCWhere 
1.2=2
1.dll
1/0-0
1/151I1
1/1m1z1
1/1U1
1:1I1d1{1
1?2h2
1@1v1
1`2f2
1`2t2
1+1:1H1T1`1n1~1
1+2D2Z2
1<1B1W1a1
1<1D1L1T1`1
1<2O2
1>1_1
1>1P1^1p1
10             |             [EBP+10H] an untracked  local
10             | 002D        reg EDX becoming dead
10200000 102ac000   MSVCR80D     (deferred)
110708205909Z
111q1
112K2u2
1-171S1h1
1'2\2
12292v2
1-232w2
1-242;2B2I2T2Z2p2t2x2|2
1'2Y2
131:1M2k2&383t3
13181>1N1a1f1v1
14             |             [EBP+14H] an untracked  local
141;1Q1t1
141[1
151D1U1
152S2m2w2
161E1Q1_1
161F1i1
181D1d1l1
181W1
182?2
191g1
191R1
192V2
1b1n1
1B2N2Z2a2
1D2R2
1d2x2
1E2S2v2
1F1U1u1
1f1x1
1g2U3
1I1[1
1J1p1
1K1x1
1L2P2T2X2\2`2d2h2
1Q1r1
1S1Z1
1U2i2
1V1h1
1V1k1
1W2^2
1X1_1
2 2$2(2,202
2 2(20282D2h2
2 2'2]2g2q2{2
2!2-222]2
2!3-3U3]3b3i3
2"3(393S3]3
2"3.3<3L3Y3
2"3U3
2#2)2>2D2Y2_2s2y2
2#2-2h2
2#2-2q2
2#353V3k3
2$2(282<2D2\2l2p2
2$2,242@2d2
2$242D2T2d2t2
2$3;3j3
2%2*252B2I2N2Y2f2m2r2}2
2%2G2r2
2&2@2J2
2&272D2
2&282
2&313K3u3
2&333`3~3
2&383v3
2(2-2c2|2
2(2P2X2\2d2
2(2t2
2) other runtime allocation failure
2) The CLR Thread ID
2) The thread has been "hijacked" in order to allow a garbage collection.
2) When you need more complex logic for stopping on a CLR exception
2)242J2^2g2
2)373
2)3M3
2*2:2
2*272L2S2x2
2,282@2\2|2
2,2N2y2
2,333N3i3
2. Instruct the runtime to stop the next time it collects that generation using 
2.2;2u2
2/2A2S2e2
2:2@2T2q2
2:2A2P2q2
2@2X2j2o2
2@3X3^3u3
2`3g3
2+212?2I2
2+363;3_3
2<2@2D2H2W2e2r2
20220915021233.835Z0
20220915051411Z
20220916051411Z0w0=
203A3f3
210930182225Z
212L2i2
2'2;2I2R2
220302185137Z
220512204601Z
222<2
222N2Y2x2
222S2a2
2'232H2f2x2
230012+4705290
230511185137Z0
230511204601Z0t1
232:2U2
232@2`2
2'343\3n3
242]2d2k2z2
24393V3a3~3
253B3i3
260708210909Z0~1
262D2~2
262E2
272B2G2L2g2q2
282D2d2p2
283?3n3u3
293@3q3
2B3`3
2D2Z2a2
2D9-$
2f2{2
2f2x2
2F3U3
2K2l2
2K2Z2
2L2l2|2
2M2_2j2
2m3u3
2N3\3
2N3e3v3
2O2j2
2O2V2=4B4W4^4h4q4}4
2r2{2
2R2Z2o2
2R3q3
2S3x3|3
3 3$3(3,3@4h4
3 3<3G3L3Q3r3
3 3g3
3 3X3x3
3 4W4
3#3+353G3O3Y3k3s3}3
3#323J3l3
3$3,343@3`3h3p3x3
3$3,343<3D3L3T3`3
3$3<3L3P3`3d3h3p3
3$343D3T3d3t3
3$4)4U4c4
3&4;4t4z4
3&4+4=4c4x4
3&484h4o4
3(30383@3H3P3X3`3h3t3
3(383H3X3h3x3
3(3K3u3
3(4`4
3) some other code you use throws a managed OOM exception 
3) The OS thread ID.  
3) The thread is currently in managed code.
3)3`3
3*313
3*3H3t3
3,3<3H3f3
3,323G3O3^3f3v3~364Q4b4{4
3,43494s4
3,474
3. When the next GC starts, and has proceeded past the mark phase a CLR 
3.3<3T3a3|3
3.353W3u3|3
3.3F3X3
3.3F3x3
3/3@3Q3b3s3
3/4\4l4
3;3U3_3u3
3;4A4V4`4
3?4l4
3@3`3h3p3x3
3+3k3
3+4M4
3+4X4
300930183225Z0|1
32494W4x4
324F4X4i4
3-3=3
3'3>3R3^3l3w3
3'3>3V3c3
333=3z3
334A4f4x4
3'3D3K3a3
3-4I4
3560   9.980618994 : `GC`GCROOTS`         GcScanHandles (Promotion Phase = 0)
3560   9.981124963 : `GC`                 GC Heap 00000000
3560   9.981125103 : `GC`                     Generation 2 [00C61000, 00000000
3560   9.981125529 : `GC`                     Generation 1 [00CED070, 00000000
3560   9.981125726 : `GC`                     Generation 0 [00CED07C, 00000000
3560   9.981125826 : `GC`                         Segment mem 00C61000 alloc 
3560   9.981135033 : `GC`GCALLOC`GCROOTS` ========== ENDGC 4194 (gen = 2, 
3560   9.981137099 : `SYNC`               RareEnablePremptiveGC: entering. 
36 D4 8C C7 AA |
363C3n3u3
38             | 0036        reg EDI becoming dead
3A3G3\3f3
3A4H4
3C3e3
3C4J4
3F4j4
3f4x4
3H3]3k3t3
3H3_5x5
3H3j3
3H3m3
3http://www.microsoft.com/pkiops/docs/primarycps.htm0@
3http://www.microsoft.com/pkiops/Docs/Repository.htm0
3K3[3
3K3P3
3Phlp
3QPhx$
3T3Z3o3y3
3Z3k3
4 4$4(4,4044484<4@4D4H4L4P4T4X4\4`4d4h4l4p4t4x4|4
4 4(40484@4H4P4X4`4h4p4x4
4 404T4`4h4
4 5,545\5`5|5
4 5@5Z5
4 5s5
4 sections in file
4!464@4U4e4
4!4E4Q4_4o4
4!4i4C5g5
4!5/5v5
4"414>4c4x4
4"4Y4m4
4"575H5
4"5n5
4#4,454>4G4P4Y4b4k4t4x4|4
4#4>4E4x4
4$4,444<4D4L4T4\4d4l4t4
4$4,444<4D4L4T4\4d4l4t4|4
4$444D4T4d4t4
4$4D4L4T4`4
4&41464;4Y4
4&4D4Q4
4&5T5+6
4(4;4Y4`4
4(4f=t=
4(4H4T4t4|4
4)4P4
4)4Q4v4
4)525N5U5o5~5
4)5A5F5
4*4c4i4~4
4,464_4e4y4
4. Now we can use the !FindRoots <object address> to find out the cross 
4.4b4n4|4
4.4T4c4u4{4
4.8.9105.0
4.8.9105.0 built by: NET481REL1LAST_C
4/4Q4s4
4`4}4
4+4;4K4[4e4
4+4<4L4
4+4A4F4[4z4
4+4J4Q4g4
4+4t4
4<4[4f4
40:0O0Y0
405Z5
414|4
415a5
41PhT
42484L4i4s4
44             |             [EBP-04H] an untracked  local
4'404f4{4"5.5<5L5X5p5
44494>4U4[4o4
444B4i4
4-53595h5p5
454Q4m4
4'5g5
465D5
475y5
494g4
496A6x6
4A             | 0027        reg ECX becoming live
4A4t4
4A5G5\5f5
4a5h5}5
4D4H4L4P4T4X4\4`4d4h4l4p4t4x4|4
4d4m4y4
4E5L5v5
4f4|4
4f4m4
4F4R4
4F4X4
4F5c5
4N4`4x4
4'OC.P
4P4g4m4
4P4V4w4
4Q4w4
4q6l=
4V4h4
4V5u5|5
4V6h6
4-Wzk
4X4_4k4|4
5 5(50585@5H5P5X5`5h5p5x5
5 5(50585@5H5P5X5`5h5t5
5 5(545X5x5
5 5*5
5 5[5
5!5C5Q5]5g5s5
5$5/5
5$5>5b5o5
5$515J5Q5[5v5
5$545D5T5d5t5
5$5H5h5p5x5
5$6,646<6D6L6T6\6d6l6t6|6
5$6@6_6
5$6L6q6
5%5`5m5
5%5{5
5%5K5V5
5%6M6u6
5&5/5
5&5;5
5&5+575=5P5U5d5l5
5(),k
5(5/5M5T5
5(5q5~5
5(9\9
5)5[5h5
5*595K5n5x5
5,5<5I5f5|5
5,5<5U5w5
5,5R5q5
5.575
5.5J5s5
5.5m5
5.5M5c5u5|5
5/5[5
5:5e5
5:6G6l6
5?5r5
5?5Y5z5
5+6H6t6
5<5\5|5
5=5O5[5i5
505J5T5
526F6S6o6
545F5X5
545T5t5
5'5?5W5o5
555E5L5^5r5
556@8E8
5'5E5c5
56             | 0025        reg EDX becoming live
565>5U5c5q5y5
565B5W5]5r5x5
566H6
575_5
586=6B6G6L7S7
595a5
595C5
5a000000 5a0b1000   mscoree      (deferred)
5a140000 5a29e000   clrjit     (deferred)
5A5H5z5
5A5K5U5_5i5s5
5B5I5
5b660000 5c440000   mscorlib_dll     (deferred)
5B6I6[6r6}6
5B6R6
5ba57bf8      318     18136 System.String
5ba5db04        1        68 System.Threading.Thread
5ba61f18        1        12 System.Collections.CaseInsensitiveComparer
5ba6cf78        1        24 Microsoft.Win32.SafeHandles.SafeFileHandle
5ba73e28        2       112 System.IO.StreamWriter
5ba75d54        1        12 System.Security.Permissions.SecurityPermissionFlag
5ba7607c        1        12 System.Security.Permissions.HostProtectionResource
5ba88bd8        3     10256 System.Object[]
5C5b5i5
5d1d0000 5e13c000   clr     (deferred)
5D5J5_5i5
5F5X5}5
5G5S5a5q5
5G6a6q6
5Genu
5H6^6f6w6
5ineI
5K5Z5h5
5Q6_6
5r6~6
5S6d6E8X8
5W5e5
5Y6l6
6 6$6(6,6064686<6@6D6H6L6P6T6X6\6`6d6h6l6p6t6x6|6
6 6$6(6,606P6X6\6h6
6 6(60686@6H6T6x6
6 6*6S6Y6j6
6 6.6>6
6 7?7J7Y7i7
6 7'7<7
6!6/646D6I6a6g6l6w6
6!6?6K6[6
6!6d6
6!787M7d7q7
6"6k6
6"757<7J7R7w7|7
6#6(62696@6G6N6U6Z6g6l6}6
6#636A6K6U6_6i6s6}6
6#6-626A6N6{6
6#686M6b6w6
6$6,646<6H6h6p6|6
6$6,686X6d6
6$646D6T6d6t6
6$686?6U6t6
6$7<7G7
6%6;6B6P6V6o6u6
6%6X6_6
6&6=6
6&626J6W6^6d6
6&787q7x7
6(6a6g6|6
6(6r6
6(7b7
6)636G6a6|6
6*6f6u6
6.6c6
6/6G6_6w6
6/6u6
6;6B6
6-;E=
6;w\u
6@6f6x6
6[6a6
6^6v7~7
6`7d7
6+7q7
60686@6H6`6h6p6|6
606O6l6
606R6
616>6L6\6w6
616S6`6k6t6
61787H7W7^7v7}7
617M7T7m7
626F6V6
637:7V7b7~7
646\6~6
6'6.6"7.7<7L7
666C6R6\6f6u6
666E6n6
666H6q6
667H7
6'6F6T6
686@6D6`6
686V6h6
687T7U8
6A6G6\6f6
6A6S6d6
6B6q6
6b7i7
6D6_6f6
6d7h7l7p7t7x7|7
6E6c6r6|6
6F6X6
6F7T7d7
6F7X7
6g8}8
6H7[7
6I8e8
6K6P6U6Z6z6
6L7U7]7w7
6M6V6e6
6Q6Z6
6R6^6l6|6
6U6|6
6W6i6
6W7^7y7
7 7$7(7,7074787<7@7D7H7L7
7 7,7L7X7x7
7 7@7`7
7 7_7e7
7 7-7I7
7 7o7
7!71787d7k7
7!747V7d7
7!7F7U7f7p7
7"7,7E7m7
7"8J8\8t8
7#7]7d7
7#777H7Y7j7t7~7
7#8T8f8
7$7,747<7D7L7T7\7d7l7t7|7
7$7.787M7W7
7$747D7T7d7t7
7$8B8
7%72797K7i7
7%7M7i7
7%83898F8S8t8y8
7&7[7
7&7\7
7&727D7H7U7Y7q7
7&7O7U7f7
7&8<8m8
7&858<8]8f8
7&888q8w8
7(757@7\7`7d7h7l7p7t7x7|7
7(7H7P7\7
7(7H7P7X7`7h7p7x7
7(8H8P8X8`8h8p8x8
7)737J7
7)787?7D7b7n7w7~7
7,7<7H7a7
7,73797?7E7a7l7v7
7,7o7{7
7,8c8
7.777@7D7H7L7P7T7X7\7`7d7h7l7p7t7x7|7
7/757;7E7P7W7y7
7/7l7
7:7s7
7:9D9N9X9
7?7i7
7?7J7\7}7
7@8q8
7@Ph0&
7_7h7l7p7t7x7|7
7+7g7
7=7N7b7
700PP
700WP
707g7
717K7]7m7
72             | 0013        reg ESI becoming live
727A7W7
728K8c8
747M7U7]7
748~8
767J7U7\7u7
767K7
768d8
768K8
768Q8\8
7'747?7H7P7Z7`7f7l7x7
777>7
7-7F8X8v8{8
7-7H7c7
7-7K7_7e7
7-848
787@7H7P7\7|7
7B8f8n8
7D7b7g7n7s7
7F7R7
7f8s8
7f8w8
7H7f7
7h8l8p8t8x8|8
7H8v8
7J8V8d8t8
7l7r7
7PhXh
7Q7`7e7v7|7
7Q8X8
7QPh\%
7r7z7
7V7^7p7
7V7e7
7V8d8
8 8$8(8,8084888<8@8D8H8L8P8T8X8\8`8d8h8l8
8 8(80888@8H8P8X8`8h8p8x8
8 9+9o9
8!8(8/868=8D8K8R8Z8b8j8v8
8!8+858?8S8
8!9Q9
8!9w9
8"8F8M8h8o8
8"9:9Z9n9|9
8#8*8H8N8c8k8z8
8$8,848<8D8L8T8\8d8l8t8|8
8$808P8\8|8
8$808T8t8|8
8$848D8T8d8t8
8$8I8v8
8$919`9p9
8$9b9i9z9
8%8,8:8C8Y8`8r8y8
8&8m8
8&939
8&939v9
8&949K9\9
8(888
8(8A8F8V8u8}8
8(8H8h8
8(8P8x8
8)828;8B8K8R8[8b8k8r8
8)858@8R8^8t8
8)9=9i9v9
8*8:8^8x8
8*848>8C8W8h8y8
8*848G8O8b8j8o8
8,8<8g8
8,8q8
8/868h8o8
8:8]8
8;0tos
8;8V8h8
8@9f9s9
8[9o9
8] j0
8+848C8M8W8a8
8+858I8{8
8+9@9Z9
8<9k9
808_8
808H8f8
81979L9V9
828Z8
83             | 0016        push ptr  0
838k8
848@8`8h8t8
848<8D8L8T8\8d8l8t8|8
849?9F9K9i9}9
868c8u8
868H8
879^9
8-8`8k8
8-9:9U9b9
8'9\9c9
8-949;9N9j9t9
898G8W8
8-9K9X9v9{9
8B             | 0019        push ptr  1
8C8I8s8y8
8C9v9
8d:l:
8F8U8w8~8
8H8h8
8I8d8
8I9a9s9
8j8q8
8J9V9_9
8K:f:x:
8N9w9
8R9\9
8r9{:
8V8c8n8
8w9+:X;
8X8p8
8Y8l8
8Z9U:
9 9(90989@9H9P9X9`9h9p9x9
9 9;9B9
9 929:9M9T9
9 9V9h9
9!:9:
9!969@9l9u9
9!9'9.959<9C9J9Q9X9`9h9p9{9
9":Y:t:
9"999>9E9L9S9Z9a9h9o9v9}9
9"9f9x9
9#:3:R:j:|:
9$9,949<9D9L9T9\9d9l9t9|9
9$9,989X9`9h9p9x9
9$949D9T9d9t9
9%909
9%9k9q9
9&:V:
9&9-949;9B9I9P9W9^9e9
9&9X9
9(9H9h9p9
9(9L9l9t9|9
9)9R9w9
9)u2+
9*9=9H9O9b9
9,:;:H:]:|:
9,9<9
9,9094989<9@9D9H9L9P9T9X9`9d9
9.:v:
9.9N9
9/9:9
9/999v9
9':@:]:h:
9:9n9
9':C:_:
9?:^:
9?9a9l9
9+:V:j:
9+9O9
9<:e:
9<9D9P9p9x9
9<9H9h9t9
9=9P9h9y9
909<9`9
919i9
91BMT
92:::@:Q:a:e:r:
92:::H:T:
92:P:|:
929i9
929Z9
93             | 001C        push ptr  2
93 F3 40 05    |
939f9x9
95:C:a:n:
95:U:
959m9
969[9b9
969X9j9
98:<:@:D:H:L:P:T:X:\:k:
9'9.93999S9`9h9o9
9'9;9@9O9x9
9'9>9D9_9e9}9
9-9L9
9A:R:
9B             | 001F        push ptr  3
9B7A-94635BEEBDDA&displaylang=en
9b9i9
9d:i:
9E WW
9E:h:
9F:T:m:
9f9x9
9H:Y:s:
9H9`9~9
9H9}9
9hhSMu
9j:q:
9J:q:y:
9N:6<v<
9N;f;x;&=8=&?8?
9O9j9
9p u"
9P9U9
9r:~:
9R:v:
9U9g9}9
9V:h:
9wLv9
9Z:a:w:
a code address in a managed function into a MethodDesc:
a COM interface pointer to which the object has been marshaled.
a garbage collection occurs, the collector needs to know where roots are so it 
A handy supplement to this function is to also run "lm v m clr". That 
A leak may still exist because in a general scan of process memory SOS can't  
a managed thread is making a PInvoke call to a Win32 function, that thread 
A minidump without full memory may not have this information.
A RuntimeCallableWrapper is an internal CLR structure used to host COM objects
a simple program:
A special note about -type: Often, you'd like to find not only Strings, but
A SyncBlock is a holder for extra information that doesn't need to be created 
a value class is not a first-class object with it's own MethodTable as the
a_o=8u
A1<Fu
abcdefghijklmnopqrstuvwxyz
ABCDEFGHIJKLMNOPQRSTUVWXYZ
able to rule out or include them as a source of a memory leak.
Abort Initiated
Aborted
about that method. You could run !U, !DumpMT, !DumpClass, !DumpMD, or 
Abstract, 
ACTIVE
Ad;Adt~
add.ovf
add.ovf.un
Adding pending breakpoints...
Additional examples:
-addr
Address
Address            Gen   Heap   segment            begin              allocated           size
Address          Gen Heap segment          begin            allocated         size
Address  Gen Heap segment  begin    allocated size
Address %#p is not in the managed heap.
Address %#p not found in the managed heap.
Address %p does not lie in the managed heap
addresses in the call stack to get more information on each managed method.
ADUnloadHelper 
advapi32
After:  
After:  0x2800134           72 (0x48      ) System.Threading.ThreadAbortException
After:  couldn't find any object between %#p and %#p
af-ZA
af-za
All handles found
all loaded modules in all domains. And remember that you can browse all the
all of the pending breakpoints. If the pending breakpoint has a non-zero 
All pending breakpoints cleared.
allocated
AllocProtect
AllowOptimize=0
-allReady
-allReady Specifying this argument will allow for the display of all objects 
also lists heaps associated with the JIT compiler, and heaps associated with 
amd64
amount of managed memory that is still alive.  This is due to the fact that a 
an Address string. You can use !ObjSize to identify any particularly large 
An assembly can consist of multiple modules, and those will be listed. You can
An error occurred while traversing the cleanup list.
an IL offset as an optional parameter seperate from the name. If there are overloaded
an object through the GCs.
an untracked %s%s local
AnalyzeOOM
analyzeoom
and for a class:
And for explicitly implemented methods on generic interfaces:
and maps it to a MethodDesc, which can be passed to !DumpMD.
and reports what it found. If a handle is found, you'll see the address of the
and the handle was discarded without freeing it.
and the types referenced by the module. For example:
Any Assembly pointer in the output can be passed to !DumpAssembly. Any Module 
api-ms-
api-ms-win-appmodel-runtime-l1-1-1
api-ms-win-core-datetime-l1-1-1
api-ms-win-core-fibers-l1-1-1
api-ms-win-core-file-l2-1-1
api-ms-win-core-localization-l1-2-1
api-ms-win-core-localization-obsolete-l1-2-0
api-ms-win-core-processthreads-l1-1-2
api-ms-win-core-string-l1-1-0
api-ms-win-core-synch-l1-2-0
api-ms-win-core-synch-l1-2-0.dll
api-ms-win-core-sysinfo-l1-2-1
api-ms-win-core-winrt-l1-1-0
api-ms-win-core-xstate-l2-1-0
api-ms-win-rtcore-ntuser-window-l1-1-0
api-ms-win-security-systemfunctions-l1-1-0
AppDomain transition
AppDomain: %s
AppDomain: 0014f000
AppDomains.  For example:
applied to each region. Sample output:
appropriate structures. For example, the TypeDefToMethodTableMap above can be 
April
ar-AE
ar-ae
ar-bh
ar-BH
ar-DZ
ar-dz
are able to run other SOS commands, but they may fail with unexpected errors 
are printed as the final portion of the output.
are two special domains: the Shared Domain and the System Domain.
AreFileApisANSI
ar-EG
ar-eg
arglist
args (%d)
argument for signs of corruption.
ar-IQ
ar-iq
ar-jo
ar-JO
ar-KW
ar-kw
ar-LB
ar-lb
ar-LY
ar-ly
arm64
ar-ma
ar-MA
ar-OM
ar-om
ar-qa
ar-QA
ARRAY
Array:       Rank %d, Number of elements %I32d, Type %s
Array: Rank 1, Number of elements 10, Type VALUETYPE
ar-SA
ar-sa
ar-sy
ar-SY
ar-TN
ar-tn
ar-ye
ar-YE
as it dumps it.   Use this option if heap corruption is suspected.
as.,k{n?,
Assembly
Assembly:           %s
Assembly:    %S
Assembly:   %s
Assembly: 001ca248
AssemblyReferencesMap:   %p
AssemblyReferencesMap: 03ec012c
associated with it. For example, this output from K:
Assuming a uncorrupted GC heap.  If this is a crash dump consider -verify option
async pinned
Async Pinned Handles:
AsyncPinned
At this time !GCRoot should be used instead.
At this time you can use SOS commands. To turn off spurious notifications,
atan2
Attempt to move past the end of the iterator.
Attempted to run: %s
Attempting to dump GC log to file '%s'
Attempting to dump Stress log to file '%s'
Attempting to dump Stress log to file 'StressLog.txt'
Attempting to read Stress log
Attributes: 
Attributes: PEFile
August
aUjR?
Avail
AVERAGE
az-az-cyrl
az-AZ-Cyrl
az-AZ-Latn
az-az-latn
b_o=8u
b1: %S
b2: %S
b3: %S
b4: %S
b5: %S
b6: %S
b7: %S
b8: %S
b9: %S
ba w4 /1 %p "bp poi(%p); g"
Background
BackgroundThread:
bad array new length
bad exception
bad import
bad object: %#p - bad MT %#p
BAD TIME
BaseSize:
BBF;u
BC .=
be created for MyObject, and the thread ownership information stored there 
be passed to !DumpDomain to limit output only to that AppDomain. Other 
be respected because it truly reflects what happened during GC.
be returned. More generally, "-type <Substring of interesting type>[]".
be-BY
be-by
Because people often want to restrict the search to gc handles and freachable
because required areas of memory are not mapped in or only partially mapped 
Before running any of the Hist - family commands you need to initialize the SOS 
Before: 
Before: 0x28000a4           72 (0x48      ) System.StackOverflowException
Before: 0x28000ec           72 (0x48      ) System.ExecutionEngineException
Before: couldn't find any object between %#p and %#p
begin
Begin %p, size %x
Begin %p, size %x. Cold region begin %p, size %x
beginning of a managed object (based on a valid method table) and the object 
behavior.
beq.s
best way to debug a managed program at this level.
between managed and unmanaged code. You could run !IP2MD on the return 
bg-BG
bg-bg
bge.s
bge.un
bge.un.s
bgt.s
bgt.un
bgt.un.s
Bhttp://www.microsoft.com/pki/certs/MicRooCerAut2011_2011_03_22.crt0
binaries for that version of the Runtime, the Windows Debugger will load the
binary array. If _stackTraceString field is not filled in, that can be helpful 
binary to a file, so you can disassemble the code and browse types with ILDASM.
binary. Be sure to list any new commands here.
ble.s
ble.un
ble.un.s
BLK COUNT
block and the handler block. For a TYPED handler, this would be the "try" and
Blocking GC for Stack Overflow
blt.s
blt.un
blt.un.s
bne.un
bne.un.s
bn-in
bn-IN
Boolean
bp %p
bp /1 %p
break
break occurs, in other words, if you need to break on the next collection you 
breakpoint for any instantiation that will be JIT-ted in the future.
Breakpoint set
brfalse
brfalse.s
-brick
brtrue
brtrue.s
bs-BA-Latn
bs-ba-latn
Buffer overflow while enumerating handles.
but !ObjSize lists 152 bytes:
But it could be handy sometimes.
BVj(j
By default, MinidumpMode is 0, so there is no restriction on commands that will
By looking at the code corresponding to Worker.Work()+0x79 (run "!u 03f00229"),
by memory pressure for better performance. You can also see the notion of 
by the orphaned handle. If the number doesn't grow over time, note that there 
By using !EEHeap to keep track of the growth of these private heaps, we are 
ByRef
byref
ByRef
BYREF
byref 
c:\Code\prj.mini\exc.cs @ 38:
c:\Code\prj.mini\exc.cs @ 39:
c:\pub\out.tmp already exists, it will be overwritten.
C;^8u
C@;C@t
C\;C|w
c_o=8u
ca-ES
ca-es
call 
Call Site
call those when an AppDomain shuts down.
called a ThinLock will be used if there is not already a SyncBlock for the 
caller.sp
caller.sp%c%x
caller.sp%c%x 
calli
callvirt
can also pass * as the <module name> to search all loaded managed modules.
can get false positives because even though the value was found, it might be 
can limit the output by passing "-gc" or "-loader". All information will be 
can move around in the garbage collected heap.
can occur while that thread is running. For example, if you break in while
can run !DumpMT to verify that. The MethodDefToDescMap takes a MethodDef token 
can update them with new object pointer values.
candidate is validated. This helps to eliminate false positives. It is not
Cannot specify both -live and -dead.
Cannot specify both -mt and -type
Can't get either WKS or SVR GC's config log buffer
Can't get either WKS or SVR GC's log file
Can't get Watson Buckets
-card
card bundles
castclass
catch(%S) 
CCW             %d
CCW:               %p
CCW:         %s
cCwD|k1
Cd;Cd
cgt.un
ChangePoint
Child SP
ChildEBP RetAddr
ChildEBP RetAddr  Caller, Callee
ChildFP  RetAddr  Caller, Callee
Chttp://www.microsoft.com/pkiops/crl/MicCodSigPCA2011_2011-07-08.crl0a
ckfinite
class
Class
CLASS
class 
Class Attributes:    %x  
class G3<T1, T2, T3> 
Class initialization
Class Name
Class Name:      %S
Class:        %s
Class:        03ee1424
Class: 03571358
Class: 03ee1424
ClassLoader:        %p
ClassLoader: 001ca060
Clause:  [%p, %p] [%x, %x]
Clause: [033bbd2b, 033bbd3c] [8b, 9c]
Clause: [033bbd7a, 033bbdc5] [da, 125]
Clause: [033bbd83, 033bbda3] [e3, 103]
cleanup the previous resources.
cleanup through the !FinalizeQueue command.
-clear
-clearall
CLEARED
Cleared
ClimbingMove
CLOSED
CloseHandle
CLR not loaded
CLR notification: GC - end of mark phase.
CLR notification: GC - Performing a gen %d collection. Determined surviving objects...
CLR Owns
CLR Version: %u.%u.%u.%u
clr!StressLog::theLog
clr!SVR::gc_config_log_buffer
clr!SVR::gc_config_log_buffer_offset
clr!SVR::gc_log_buffer
clr!WKS::gc_config_log_buffer
clr!WKS::gc_config_log_buffer_offset
clr!WKS::gc_log_buffer
CLR.DLL by running 
CLRCreateInstance
CLRDEBUGINFO
CLRDEBUGINFOWINDOWSX86
clrgc!SVR::gc_log_buffer
clrgc!WKS::gc_log_buffer
CLRProfiler
CLR-specific data, just enough to run a subset of SOS commands correctly. You 
ClrStack
CLRStack
clrstack
CLRStack
CLRStack attempts to provide a true stack trace for managed code only. It is
CLstatic
clt.un
CMOD_OPT
CMOD_REQD
CoCreateInstance
Code %x 
Code size: %x
CodeAddr = %s
CodeAddr:     %s
CodeAddr:     03ef00b8
CodeAddr: 033bbca0
CodeAddr: 03ef00b8
codelabel
CoInitialize
CoInitialized
Cold region:
collect_classes = 0) ==========={
COLLECTED
collected. Why? Who is holding onto them?"
collection of the specified generation.  The effect is reset as soon as the 
collection statistics about objects. With it's various options, it can look for
COM Context:                %p
COM interface pointers:
combined with a high rate of allocation. Here is example output where !DumpHeap
ComClassFactory
ComClassFactory %d
ComImport, 
Command cancelled at the user's request.
command to use becomes:
command will not display any managed OOM because we will throw OOM right away 
command, say it is gen 1:
COMMAND: %s.
COMMAND: <cmd name, all lower case>
COMMAND: analyzeoom.
COMMAND: bpmd.
COMMAND: clrstack.
COMMAND: comstate.
COMMAND: contents.
COMMAND: dumparray.
COMMAND: dumpassembly.
COMMAND: dumpccw.
COMMAND: dumpclass.
COMMAND: dumpdomain.
COMMAND: dumpheap.
COMMAND: dumpil.
COMMAND: dumplog.
COMMAND: dumpmd.
COMMAND: dumpmodule.
COMMAND: dumpmt.
COMMAND: dumpobj.
COMMAND: dumprcw.
COMMAND: dumpruntimetypes.
COMMAND: dumpsig.
COMMAND: dumpsigelem.
COMMAND: dumpstack.
COMMAND: dumpstackobjects.
COMMAND: dumpvc.
COMMAND: eeheap.
COMMAND: eestack.
COMMAND: eeversion.
COMMAND: ehinfo.
COMMAND: faq.
COMMAND: finalizequeue.
COMMAND: findappdomain.
COMMAND: findroots.
COMMAND: gchandleleaks.
COMMAND: gchandles.
COMMAND: gcinfo.
COMMAND: gcroot.
COMMAND: gcwhere.
COMMAND: heapstat.
COMMAND: histclear.
COMMAND: histinit.
COMMAND: histobj.
COMMAND: histobjfind.
COMMAND: histroot.
COMMAND: ip2md.
COMMAND: listnearobj.
COMMAND: minidumpmode.
COMMAND: name2ee.
COMMAND: objsize.
COMMAND: printexception.
COMMAND: procinfo.
COMMAND: rcwcleanuplist.
COMMAND: savemodule.
COMMAND: stoponexception.
COMMAND: syncblk.
COMMAND: threadpool.
COMMAND: threads.
COMMAND: threadstate.
COMMAND: token2ee.
COMMAND: traverseheap.
COMMAND: u.
COMMAND: verifyheap.
COMMAND: verifyobj.
COMMAND: vmmap.
COMMAND: vmstat.
Comments
Commit
compacting GCs
Compacting reasons
CompanyName
Completed successfully.
completely agree with what this command tells you, in which case the command should
Completion Port Thread
Completion Port Thread:
complex, like 'price, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
ComponentSize:
compressed stream of data indicating when registers or stack locations contain 
COMState
comstate
Conceptually the output is:
concurrent GCs
Condemned generation: 1.
CONOUT$
consistency errors.
constrained.
Content:     
contents
CONTEXT
Context
Context information:
ContextStaticOffset: %x
ContextStaticsSize:  %x
conv.i
conv.i1
conv.i2
conv.i4
conv.i8
conv.ovf.i
conv.ovf.i.un
conv.ovf.i1
conv.ovf.i1.un
conv.ovf.i2
conv.ovf.i2.un
conv.ovf.i4
conv.ovf.i4.un
conv.ovf.i8
conv.ovf.i8.un
conv.ovf.u
conv.ovf.u.un
conv.ovf.u1
conv.ovf.u1.un
conv.ovf.u2
conv.ovf.u2.un
conv.ovf.u4
conv.ovf.u4.un
conv.ovf.u8
conv.ovf.u8.un
conv.r.un
conv.r4
conv.r8
conv.u
conv.u1
conv.u2
conv.u4
conv.u8
converted pins
ConvertThreadToFiber
Cooperative
CopyCtor
CorExitProcess
correct mscordacwks.dll file.
correspond to SOS command names. This file is embedded as a resource in the SOS 
corresponding to objects that are owned by a thread. For example, a
corruption bug caused by invalid GCEncoding for a particular method.
could increase this to get more logging, but more memory will be required for 
Could not allocate memory to read the gc info.
Could not do a full GC
Could not read address %p.
Could not read address of format string
Could not read memory %p
Could not request method table data for object %p (MethodTable: %p).
Could not request segment data at %p.
couldn't allocate gaps
Couldn't get size for object %#p: possible heap corruption.
Count
counters or debugger commands. For example for the former scenario the "!address 
cpblk
cpobj
CPU utilization: %d%%
-create
-create2
CreateEventW
CreateFiber
CreateFileA
CreateFileMappingA
CreateFileW
CREATING
creating a breakpoint against a module that has not yet been loaded.
Creating thread:            %p
cRg!m
Critical
cs-cz
cs-CZ
curr_object : 00a73d24
curr_object:      %s
curr_object: %p > end_youngest: %p
curr_object: %p > heap_segment_allocated (seg: %p)
Current frame: 
current managed thread. (A nested exception occurs when you throw another
Current mode: %s - unsafe minidump commands are %s.
Current:
cxr@%p
cy-gb
cy-GB
D$,PQ
D$PVW
d_o=8u
D=xz#
D7L7T7\7d7l7t7|7
D8(Ht
D8(Ht5F
D8(HXt:f
da-dk
da-DK
dbgeng.dll
dbghelp.dll
DbgHelper 
dclog
DDBLD303D
dddd, MMMM dd, yyyy
de00 
de01 
de02 
-dead
-dead     Only print dead objects (objects which will be collected in the
DeadThread:
de-at
de-AT
Debug Suspend Pending
Debug Will Sync
DebugBreak
DebugCreate
DebugExtensionInitialize
DebugExtensionNotify
DebugExtensionUninitialize
debugger "U" function, the entire method from start to finish is printed,
debugger is configured to load line number information.
December
de-CH
de-ch
DecodePointer
decoder failed
de-de
de-DE
default one.
defined on the object. 
DeleteCriticalSection
DeleteFiber
de-LI
de-li
de-LU
de-lu
demotion
Dependent
dependent
Dependent Handles:
-derived
Detached
-detail
-detail   Will display extra information on any SyncBlocks that need to be 
Detail: %s: %s (%d bytes)
Detail: LOH: Failed to reserve memory (16777216 bytes)
Detail: SOH: Didn't have enough memory to grow the internal GC datastructures (800000 bytes) - 
-details
details can be obtained by passing the pointer value to !PrintException. If
determine if it is still in use.
diasymreader.dll
Did not find a path from %p to %p.
Didn't find %d handles:
Didn't have enough memory to allocate an LOH segment
Didn't have enough memory to commit
Didn't have enough memory to commit beginning of the segment
Didn't have enough memory to commit the internal GC datastructures
Didn't have enough memory to commit the new ephemeral segment
Didn't have enough memory to grow the internal GC datastructures
differentiate between garbage and valid structures, so you may have false     
differing reloc values for this object!
difficult because it requires some internal info from GC. The only exception is
directly. Be careful about using this to set memory breakpoints, since objects
disabled
disassemble the frame that the local or argument value belongs to in order to 
disassembly of the JITTED code. You can also call !DumpClass, !DumpMT, 
disassembly. The -n (No line numbers) flag can be specified to disable this
Display of context static variables is not implemented yet
displayed otherwise.
displaying, finding or traversing objects as well as gc heap segments may not 
disturb a fragile repro environment. The !DumpLog function allows you to write 
div.un
div-MV
div-mv
DllBase
DllGetClassObject
DOCUMENTATION
Documentation for %s not found.
documentation). Finally, it will provide a warning if it detects excessive 
doesn't match the version of CLR.DLL. You can find the version of 
Domain
Domain %d
Domain %d:%s          %s
Domain 1: 14f000
don't have an instance of the class, so !dumpobj won't help you), note that
don't have the original DLLs or EXEs. This is most often used to save a managed
Double
double
dump creation time to bring those structures into the minidump, and allow a 
dumparray
DumpArray
DumpArray (da)                     ThreadState
dumpassembly
DumpAssembly
DumpAssembly                       ProcInfo 
Dumpccw
DumpCCW
dumpccw
DumpCCW
DumpClass
dumpclass
DumpClass                          ListNearObj (lno)
dumpdomain
DumpDomain
DumpDomain                         VerifyHeap
dumpgcconfiglog
DumpGCConfigLog
dumpgcdata
DumpGCData
dumpgclog
DumpGCLog
dumpheap
DumpHeap
DumpHeap                           U
DumpIL
dumpil
DumpIL                             MinidumpMode 
Dumping GC log at %08x
Dumping managed stack and managed variables using ICorDebug.
dumplog
DumpLog
Dumplog
DumpMD
dumpmd
DumpMD                             GCHandles
DumpModule
dumpmodule
DumpModule                         FindAppDomain
dumpmt
DumpMT
DumpMT                             GCWhere
dumpobj
DumpObj
DumpObj (do)                       Threads
Dumprcw
dumprcw
DumpRCW
DumpRCW                            AnalyzeOOM (ao)
dumpruntimetypes
Dumpruntimetypes
DumpRuntimeTypes
DumpRuntimeTypes                   DumpLog
DumpSig
dumpsig
DumpSig                            VMMap
dumpsigelem
DumpSigElem
DumpSigElem                        StopOnException (soe)
dumpstack
DumpStack
dumpstackobjects
DumpStackObjects
DumpStackObjects (dso)             IP2MD
dumpvc
DumpVC
DumpVC                             DumpStack
Duplicate promote/relocs
dword ptr [
dword ptr ds:[
Dynamic 
Dynamic Module
dynamic statics NYI
dynamic thread statics NYI
E VPW
e_.,>
e+000
E0             | 002D        pop  4 ptrs
E0C1)0'
Each thread has many attributes, many of which can be ignored. The important 
EBP%c
EBX%c
EDI%c
-EE will only show managed functions.
EEClass has an invalid MethodTable address
EEClass:
EEClass:     %s
EEClass:     <error getting EEClass>
EEClass:     <not loaded yet>
EEClass: 03e40fc0
EEClass: 03ee1424
EEClass: 03ee14b8
EEClass: 03ee1ae0
EEClass: 03ee1b84
EEClass: 11a538c8
eeheap
EEHeap
EEHeap                             VerifyObj
EEStack
eestack
EEVersion
eeversion
EEVersion
EEVersion                          FinalizeQueue (fq)
EHHandler %d: %s 
EHHandler %d: %s CLAUSE BEGIN
EHHandler %d: %s CLAUSE END
EHHandler %d: %s FILTER BEGIN
EHHandler %d: %s HANDLER BEGIN
EHHandler %d: %s HANDLER END
EHHandler 0: TYPED catch(System.IO.FileNotFoundException) 
EHHandler 1: FINALLY
EHHandler 2: TYPED catch(System.Exception)
Ehinfo
ehinfo
EHInfo
-ehinfo
Ehttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z
Ehttp://www.microsoft.com/pkiops/certs/MicCodSigPCA2011_2011-07-08.crt0
ei_/E6D
Element Methodtable: %s
Element Type: Value
elevation logic
el-GR
el-gr
eLK(w
enabled
en-au
en-AU
en-BZ
en-bz
en-ca
en-CA
en-CB
en-cb
EncodePointer
end       Stop listing at this address
endfilter
endfinally
endmac
en-gb
en-GB
en-ie
en-IE
en-JM
en-jm
en-nz
en-NZ
en-PH
en-ph
EnterCriticalSection
Entry
entry point %p
entry point 5b68dbb8
en-TT
en-tt
en-us
en-US
Environment
en-za
en-ZA
en-zw
en-ZW
ephemeral segment allocation context: 
Error %x while walking the handle table.
error decoding IL
Error during heap traverse
Error gathering dynamic info from object at %s.
Error getting AppDomain %p.
Error getting AppDomain friendly name
Error getting AppDomain information
Error getting card table lowest address
Error getting EEJitManager code heaps
Error getting MethodDescs for module %p
Error getting next card table
Error getting per-appdomain handle information
Error getting string data
Error getting System.RuntimeType.m_handle offset
error in import
ERROR IN SIGNATURE:  Not all of signature blob was consumed.  %d byte(s) remain
ERROR IN SIGNATURE:  Signature should be larger.
Error initialized register $t%d to zero
Error initializing heap traversal
Error loading documentation resource
Error processing exception notification
Error reading card bits
Error requesting CCW data
Error requesting COM interface pointers
Error requesting details
Error requesting gc heap analyze data
Error requesting gc heap analyze data for heap %p
Error requesting GC Heap data
Error requesting gc heap details
Error requesting heap data for heap %d.
Error requesting heap data.
Error requesting heap segment %p
Error requesting heap segment %p.
Error requesting interesting GC info
Error requesting OOM data
Error requesting RCW data
Error requesting SyncBlk data
Error retrieving nested exception info %p
Error setting breakpoint: %s
Error walking dependent handles.  GCRoot may miss paths.
Error when reading RuntimeType field
Error!
ERROR!! Bad signature blob value!
Error, unexpected opcode type
Error: %lx
Error: There is a promote record for root %p, but no relocation record
es-ar
es-AR
es-bo
es-BO
es-cl
es-CL
es-co
es-CO
es-CR
es-cr
es-do
es-DO
es-ec
es-EC
es-ES
es-es
es-gt
es-GT
es-hn
es-HN
ESI%c
es-mx
es-MX
es-ni
es-NI
ESP/REG  Object   Name
es-pa
es-PA
es-PE
es-pe
es-PR
es-pr
es-PY
es-py
es-sv
es-SV
es-uy
es-UY
es-VE
es-ve
et-EE
et-ee
eu-ES
eu-es
every exception in the System.Exception heirarchy.
every object has enough clues about it's origin to determine the AppDomain. 
ex:    StopOnException -create System.OutOfMemoryException 1
Examine a MethodTable. Each managed object has a MethodTable pointer at the 
examined:
Examining CLR data structures      Diagnostic Utilities
Examining the GC history           Other
Example for generics:
Example output:
example, if you only want to list objects in the large heap segment:
example. If a handle is not found in memory, you'll get notification of that 
Example:
Examples: !Name2EE  mscorlib.dll System.String.ToString
Exception
exception during reading PEB
Exception object: %s
Exception occurred while trying to %s the GC stats.
exception on the current thread (if any). You can use !soe as a shortcut for 
exception on the current thread and print it. This will be the same exception
Exception type:   %S
Exception type:   <Unknown>
Exception will list the last thrown exception (if any) for the thread. More
exception within a catch handler already being called for another exception).
exceptions by switching to the thread in question, and running 
execute the same code, they won't be able to enter the block until the first 
EXITED
EXITING
ExitProcess
expand in next full GC
expand promoting eph
expand with a new seg
Expansion mechanisms
Expected newline in documentation resource.
Expecting first chance CLRN exception
explore more fields.
expressed as `facility1`facility2`facility3`.  This facilitates the creation of 
ExRdWr
extension !teb to get the top and bottom stack values.
Extension commands need clr.dll in order to have something to do.
ext-ms-win-kernel32-package-current-l1-1-0
ext-ms-win-ntuser-dialogbox-l1-1-0
ext-ms-win-ntuser-windowstation-l1-1-0
ExWrCp
f;F,t
F;wTr
F\;Fxr
F0 31          | 0036        reg ESI becoming dead
F1 79          | 0011        reg EDI becoming live
F1<at
F1<gt
F2jgYf;
F4^[]
f7f0a001
f7f0a002
f7f0a003
f9:t!V
Fail to create file %s
Fail to fill AppDomain
Fail to fill Assembly
Fail to fill Module %p
Fail to read memory
Fail to read PE section info
failed to create file: %d
Failed to enumerate GC handles.  HRESULT=%x.
Failed to enumerate GC reference errors.
Failed to enumerate GC references.
Failed to enumerate threads in the process.
Failed to execute the following command: %s
Failed to find runtime DLL (clr.dll), 0x%08x
Failed to find runtime DLL (clr.dll), 0x80004005
Failed to find the segment of the managed heap where the object %p resides
Failed to gather EHInfo data
Failed to gather needed data, possibly due to memory contraints in the debuggee.
Failed to get appdomain %p, error %lx
Failed to get appdomain list
Failed to get CLR Tls data for thread 
Failed to get GC heap details at %p.
Failed to get GCHeaps
Failed to get GCHeaps.
Failed to get GCHeaps:  integer overflow
Failed to get GCHeaps:  integer overflow error
Failed to get GCHeaps: integer overflow
Failed to get GCHeaps: Integer overflow.
Failed to get header for object %p.
Failed to get method desc for %p.
Failed to get object header for object %p while inspecting syncblock at index %d.
Failed to get size of object.
Failed to get Teb for Thread 
Failed to get the dac module handle. hr=0x%x.
Failed to get the modules for the given assembly.
Failed to get thread ID for thread 
Failed to get thread type info not found for thread 
Failed to get Tls expansion slots for thread 
Failed to instantiate {%ls} from DAC location.
Failed to instantiate {%ls} from debugger's image path.
Failed to instantiate {%ls} from installed .NET framework locations.
Failed to load data access DLL, 0x%08x
Failed to parse command line arguments.
Failed to perform EHInfo traverse
Failed to read bounds info from the array
Failed to read card table entry.
Failed to read element at 
Failed to read GCDesc for MethodTable %p.
Failed to read lower bounds info from the array
Failed to read memory
failed to read memory from %08x
Failed to read module information for '%S'.  HRESULT = 0x%x.
Failed to read whole or part of stress log, some references may come from stress log
Failed to request assembly.
Failed to request GC details data.
Failed to request GC heap data.
Failed to request GCDesc.
Failed to request MethodData, not in JIT code range
Failed to request module address.
Failed to request Module data from assembly.
Failed to request module list.
Failed to request more handles.
Failed to request number of entries.
Failed to request object data for %s.
Failed to request segment data at %p.
Failed to request SyncBlk at index %d.
Failed to request Thread at 
Failed to request Thread at %p
Failed to request ThreadpoolMgr information
Failed to request threads from the thread store.
Failed to request ThreadStore
Failed to require current Thread ID
Failed to require total thread number
Failed to reserve memory
Failed to retrieve information about segment %p
Failed to retrieve segments for gc heap
Failed to retrieve Tls Data index
Failed to set code notification
Failed to Start
Failed to start stack walk: %lx
Failed to switch to original thread
Failed to switch to thread 
Failed to walk dependent handles.  GCRoot may miss paths.
Failed to walk the handle table.
Failed to walk the HandleTable!
Failed to walk thread %x
FAILURE: Stress log not dumped
FAILURE: Stress log unreadable
fa-IR
fa-ir
false
FAULT
FCALL
February
FF             |
fg:SM
Fiber
Field
Field (mdToken token) of
Field name:  %S
field only applies to RefCount Handles, and this field will contain the
FieldDefToDescMap:       %p
FieldDefToDescMap: 03ec00a4
Fields:
fi-FI
fi-fi
file %s saved
File not specified
file. This is especially useful if you are debugging a full memory dump, and 
File:
File:            %S
File:        %S
FileDescription
FileReferencesMap:       %p
FileReferencesMap: 03ec0128
FileTimeToLocalFileTime
FileTimeToSystemTime
FileVersion
FILTER
Filter: [%p] [%x]
filters for displaying only specific message categories.  To make sense of this 
Finalizable but not rooted:  
FINALIZED
Finalized
FinalizeQueue
finalizequeue
FinalizeQueue                      GCInfo
Finalizer 
Finalizer Queue:
FINALIZING
FINALLY
Finally, if GC heap corruption is present, you may see an error like this:
Findappdomain
findappdomain
FindAppDomain
FindClose
FindFirstFileExA
FindIL failed
FindNextFileA
FindResourceA
findroots
FindRoots
first field. For example:
First, all stacks will be searched for roots, then handle tables, and finally
Flags:                      %s%s%s%s%s%s%s%s
Flags:             %s%s
Flavor=Retail
float
float32
float64
floor
FlP0t
FlsAlloc
FlsFree
FlsGetValue
FlsSetValue
FlushFileBuffers
FNPTR
fo-fo
fo-FO
Followed by
followed by a report listing all the types found, their size and number:
following code is executed by Threads A & B:
following the argument address.
For a minidump created with this minimal set of functionality in mind, you
for debugging. You can of course use !DumpObj on the same exception object to 
for every object. It can hold COM Interop data, HashCodes, and locking 
For example, !DumpObj lists a size of 20 bytes for this Customer object:
For example, a GCHandle valuetype is stored on the stack with the low bit set 
For example, to display thread 3's stack use ~3kb.
For example:
for finalization. The notation "(0015bc90->0015bca0)" means that if you look at
for -l and -p combined. 
For multi-dimension array, length and start index are supported
for that variable name you specified. Here are some examples: 
for the method. (Beginning and end of try/finally/catch handlers, etc.).
For this case, just be sure to surround the module name with single quotes,
For this kind of module, simply use price as the module name:
Found %d handles:
Found %d methods in module %p...
Found %d objects.
Found %d roots.
Found %d unique roots (run '!GCRoot -all' to see all roots).
Found %p at location %p
Found %p in stress log at location %p, reference not counted
Found '%S', but it does not match the CLR being debugged.
fragmentation in the GC heap. 
Fragmented blocks larger than 0.5 MB:
Fragmented blocks larger than 1MB:
fragmented gen0 (ephemeral GC)
Frame
frame and if successful will display the corresponding source file name and 
Frame pointer: %s
fr-BE
fr-be
fr-CA
fr-ca
fr-CH
fr-ch
Free            %d
Free MethodTable
Free Object
Free space:                                                 Percentage
Free:
FreeEnvironmentStringsW
FreeLibrary
Free-Threaded Interfaces to be released: %d
frexp
fr-fr
fr-FR
Friday
fr-LU
fr-lu
fr-mc
fr-MC
from the resultant list. Here is a simple object:
ft&9q
FullDllName
Fully initialized
Function evaluation
function specifically to debug DynamicMethod code which was constructed on
function:
functions provide an AppDomain pointer as well, such as !Threads where it lists
functions. Here is sample output:
Furthermore, if the Outer class resides in a namespace, NS, the bpmd 
G$;G(u
G$;G(u+;O
G(cT5&
G;~8u
G\t!;
G1.G():
Garbage Collector attempts to collect and reclaim memory only when required to
garbage collector. The most apparent difference in the debugger is that in 
garbage in that no code knows about the address. You can also get false 
Gate 
Gathering types...
GC Alloc Context
GC can not commit memory it needs. You can look at these scenarios by using performance
GC Handle Statistics for AppDomain 
GC Heap not initialized yet.
GC Heap not initialized, so GC mode is not determined yet.
GC Heap Size   0x1201c(73756)
GC Heap Size  0x5d73a8(6124456)
GC Heap Size:    
GC heap that are not rooted anymore.
GC info %p
GC info 5b9f2f09
GC Mode
GC On Transitions
GC Refs:
GC Suspend Pending
GC_HEAP RELOCATING Objects in heap within range [%p %p) by -0x%x bytes
GCConfigLog.txt
GCCount
GCHandleLeaks
gchandleleaks
Gchandleleaks
GCHandleleaks
GCHandleLeaks will report any GCHandles that couldn't be found in memory.      
gchandles
GCHandles
gcheapstat
GcHeapStat
GCHeapStat
GCInfo
gcinfo
-gcinfo
GCLog.txt
gcroot
GCRoot
GCRoot                             EEStack
GCs that did demotion
gcwhere
GCWhere
GcWhere
gen(%#p) = %d > %d = condemned generation.
GENArray
Generally there's no need to call this explicitly, as each HistInit will first 
GenerateTrackingInfo=1
generation %d has %d finalizable objects 
generation %d starts at 0x%p
generation 0 has 4 finalizable objects (0015bc90->0015bca0)
generation 0 starts at 0x00a71018
generation 0 starts at 0x00c32754
generation 1 has 0 finalizable objects (0015bc90->0015bc90)
generation 1 starts at 0x00a7100c
generation 1 starts at 0x00c32748
generation 2 has 0 finalizable objects (0015bc90->0015bc90)
generation 2 starts at 0x00a71000
generational references to the object of interest.  In other words, even if the 
generations too, and report those roots.
generations.
GENERICArray
GenericInst slot: 
Generics inst context: 
GenN    obj_address   root1, root2, root3,
GenN-1  prev_obj_addr root1, root2,
GenN-2  prev_prev_oa  root1, root4, 
get an Assembly address from the output of !DumpDomain.
GetACP
GetCommandLineA
GetCommandLineW
GetConsoleCP
GetConsoleMode
GetCPInfo
GetCurrentPackageId
GetCurrentProcess
GetCurrentProcessId
GetCurrentThreadId
GetEnvironmentStringsW
GetFileSize
GetFileType
GetFileVersionInfoSizeW
GetFileVersionInfoW
GetFrameContext failed: %lx
GetLastError
GetModuleFileName(dacModuleHandle) failed. Last error = 0x%x
GetModuleFileNameA
GetModuleFileNameW
GetModuleHandleExW
GetModuleHandleW
GetModuleInformation
GetOEMCP
GetProcAddress
GetProcessHeap
GetProcessTimes
GetStartupInfoW
GetStdHandle
GetStringTypeW
GetSystemTimeAsFileTime
GetTimeFormatW
gfffC
Given an address in managed JITTED code, IP2MD attempts to find the MethodDesc
Given the following two classes:
given, but merely derives from it. So, "-derived System.Exception" would catch
gl-ES
gl-es
GlobalMemoryStatus
GS cookie valid range: [%x;%x)
GS cookie: 
gu-IN
gu-in
H$;H s
H(;H$v
H2M>~
H4;H0s
H8;H4v
Handle
handle
Handle (%s): %p -> %p: %d (0x%x) bytes (%S)
handle addresses that couldn't be found.
HandleCLRN
handler, it shows the type, including code addresses and offsets for the clause
Handler: [%p, %p] [%x, %x]
Handler: [033bbd3c, 033bbd50] [9c, b0]
Handler: [033bbda3, 033bbdc5] [103, 125]
Handler: [033bbdc5, 033bbdd6] [125, 136]
Handles:
HandleTable:
HANDLETABLE_NOACCESS
handy for clean, simple traces when debugging straightforward managed 
has a memory demand of 10 Megabytes. The stress log is circular so new entries 
Has tailcalls: %u
have an object pointer, and can attempt to run "!DumpObj" on it.
Heap     Gen0         Gen1         Gen2         LOH
---------Heap %#-2d---------
Heap %d
Heap %d (%p)
Heap %d: Error requesting interesting GC info
Heap %d: Error requesting OOM data
---------Heap 2 ---------
---------Heap 4 ---------
heap fragmentation. This is usually caused by pinning objects for a long time 
Heap local consistency confirmed.
Heap local consistency not confirmed.
Heap Size:       
Heap%-4d %12I32u %12I32u %12I32u %12I32u
Heap0    152212       0            306196       0           SOH: 94% LOH:  0%
Heap0    177904       12           306956       8784        
Heap0    28           12           12           64          SOH:  0% LOH:  0%
Heap1    104          12           12           16          SOH:  0% LOH:100%
Heap1    155704       0            0            0           SOH: 97% LOH:  0%
Heap1    159652       12           12           16          
HeapAlloc
HeapFree
HeapReAlloc
HeapSize
HeapStat
heapstat
heavy optimization of parameters and locals one can request the JIT compiler
he-IL
he-il
help.
Here is output for a simple program:
Here is sample output from a very simple program.  Note that the "RefCount"
Here is sample output where you can see the change in register state. Normally 
Here is some sample output:
HH:mm:ss
high fragmetation
high memory load (ephemeral GC)
high memory load and frag
higher-level summary of the objects registered for finalization. Note that 
HighFrequencyHeap: 
HighFrequencyHeap:  %p
HighFrequencyHeap:008f2000(00008000:00001000) Size: 0x00001000 bytes.
HighFrequencyHeap:00902000(00008000:00003000) Size: 0x00003000 bytes.
HighFrequencyHeap:00922000(00008000:00001000) Size: 0x00001000 bytes.
hi-in
hi-IN
Hijacked by the GC
HistClear
histclear
HistClear
histinit
HistInit
HistInit                           FAQ
HistInit command.
HistObj
histobj
HistObj
HistObjFind
histobjfind
HistObjFind
HistRoot
histroot
HistRoot
HistRoot provides information related to both promotions and relocations of the 
histstats
HistStats
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework:
HostCodeHeap:      
Hosted Runtime:
Hot region:
hr-BA
hr-ba
HResult: %lx
hr-HR
hr-hr
Ht$;}
http://blogs.msdn.com/adam_nathan/
http://www.microsoft.com/downloads/details.aspx?FamilyId=86CE6052-D7F4-4AEB-
http://www.microsoft.com0
hu-hu
hu-HU
hy-AM
hy-am
hyperlinks to inspect the different managed stack frames and managed variables.                             
ID:        %d
ID:        (shared domain)
ID:        (system domain)
ID: 1
IDebugSystemObjects::GetCurrentProcessHandle HRESULT=0x%x.
identify a possible trend.                                                    
id-ID
id-id
IDispatch/IUnknown
If 30% or more of the heap contains "Free" objects, the process may suffer from
If a token is unresolved, run "!do <addr>" on the addr given
If an error is found, !VerifyHeap will report it. I'll take a perfectly good 
If called with no parameters, PrintException will look for the last outstanding 
If given an address, this function will display the RCWCleanupList at that address.
If I wanted to save a copy of clr.dll, I could run:
If IsJitted is "yes," you can run !U on the CodeAddr pointer to see a 
if it points to a Pinned handle. So !GCHandleLeaks ignores the low bit in it's
If IT1 and ExplicitItfImpl are types declared inside another class, 
If no address is specified, it displays the default cleanup list, printing the
If not then either the module that contains the method hasn't been loaded yet
If PreEmptiveGC is enabled for a thread, then a garbage collection 
If that succeeds, the SOS command should work on retry.
If the debugger has the option SYMOPT_LOAD_LINES specified (either by the
If the pointer falls within a segment range given by "!EEHeap -gc", then you do
If there are nested exceptions, you can re-run !PrintException with the 
If this gc heap corruption exists, there is a serious bug in your own code or 
If we look at a valid signature object for a method we see the following:
If you are debugging a minidump, you need to make sure that your executable
If you are looking for a way to display a static field of a class (and you
if you are running low on commit space. One important thing to keep in mind is
If you are running version 1.1 or 2.0 of the CLR, SOS.DLL is installed in the 
If you are using a dump file created on another machine, it is a little bit
If you need this functionality, get a full memory dump with ".dump /ma mydump.dmp"
If you pass the "-xml" flag, the file is instead written out in an easy to 
If you pass the -ehinfo flag, you'll get inline display of exception info
If you pass the -gcinfo flag, you'll get inline display of the GCInfo for
If you pass the -verify option it will do more sanity checking of the heap
If you use the -verify option, each non-static CLASS field of an object
Ihttp://crl.microsoft.com/pki/crl/products/MicRooCerAut2011_2011_03_22.crl0^
IJupiterObject:    %p
IL_%04x
ilAddr = %p
illegal
Image
image). The TOTAL column is (AVERAGE * BLK COUNT). Sample output below:
importance. Shortcut names for popular functions are listed in parenthesis.
important properties of the object such as the EEClass, the MethodTable, and 
In a minidump without full memory, most gc heap structures will not be valid.
In addition to your application domain, and any domains it might create, there
In Multi Threaded Apartment
in myapp.ini and re-run:
In order for the option -lines to enable display of source information
In order to run SOS commands, many CLR data structures need to be traversed. 
in parenthesis. You can also look at the token table yourself, by
In plan phase of garbage collection
In Single Threaded Apartment
In the case of hosted environments such as SQL, the module name may be 
in the CLR. In user code, an error in constructing PInvoke calls can cause 
in the current directory is created.
In the debugger at startup you can type:
in the debugger, and let it run. After the function EEStartup is finished, 
in the debugger.  Note that if you are running CoreCLR (e.g. Silverlight)
in. At this time, SOS cannot reliably detect if a dump file is of this type 
in. You can pass this value to !DumpDomain to find out more. 
include the source file name and line number corresponding to the 
-inclUnrooted
Incorrect argument: %s
Incorrect options.  Usage:
IND)ind)
IND)ind)S
Index         SyncBlock MonitorHeld Recursion Owning Thread Info          SyncBlock Owner
Index SyncBlock MonitorHeld Recursion Owning Thread Info   SyncBlock Owner
induced compacting GC
--------info for heap %d--------
information about that:
information for thread-safe operations.
information on diagnosing the cause.
initblk
InitializeCriticalSectionAndSpinCount
InitializeCriticalSectionEx
InitializeSListHead
Initializing
initobj
inity
INITY
in-memory log capability. The idea was to avoid using locks or I/O which could 
InMemoryOrderLinks
InMemoryOrderModuleList
InnerException:   
instance
instead of even trying to allocate it on the GC heap.
int16
Int16
int32
Int32
Int64
int64
Integer overflow error.
Integer overflow on array rank
interested in objects with invalid fields.
Interesting data points
Interface, 
interfaces to display the managed stack and variables. With this option you can also 
InterlockedDecrement
InterlockedFlushSList
InterlockedIncrement
INTERNAL
Internal call
internal_root_array = %#p
internal_root_array_index = %#p
InternalName
Interrupted
interrupted by user
Interrupted, data may be incomplete.
Interruptible
IntPtr
Invalid arg
Invalid argument %s
Invalid Assembly %s
Invalid CCW %s
Invalid CCW pointer %s
Invalid EEClass address
Invalid exception object %s
invalid GC info
invalid hash bucket count
Invalid object
Invalid option %s
Invalid option: option specified multiple times: %s
Invalid parameter %s
Invalid parameters %s %s
Invalid parent EEClass
Invalid parent MethodTable
Invalid pending breakpoint index.
Invalid RCW %s
Invalid signature
Invalid stress log chunk: %p
invalid string position
INVALID TYPE %d
investigating lifetime issues of interop-heavy applications.
IOCompletion
IOCompletion 
ip2md
IP2MD
is a bug in the JIT Compiler. It parses the GCEncoding for a method, which is a
is a simple example of the output for a dynamic method:
is an instance method or a static method respectively.  The third portion of the 
is if the system is running out physical memory (+ page file if you have one) so
is no facility to read meta-information about this memory). You can turn this 
is Outer.IT1<U>.M1, using a '.' as the separator)
is owned by thread 4.
is running in "Workstation" or "Server" mode, a distinction which affects the 
is useful for investigating lifetime issues of interop-heavy applications.
IsAggregated 
IsContained 
IsDCOMProxy 
IsDebuggerPresent
IsDisconnected 
IsExtendsCOMObject 
IsFreeThreaded 
isinst
is-is
is-IS
IsJitted:     %s
IsJitted:     yes
IsJitted: yes
IsJupiterObject 
IsProcessorFeaturePresent
IsUnique 
IsValidCodePage
It creates a graphical display of the GC heap to help you analyze the state of
It is either in the "plan phase," where objects are being moved around, or
It is not always the case that a SyncBlock will be created for every object 
It means that Thread e04 owns object 00a7a194, and Thread ab8 owns object 
it off and add /D to the beginning of a command to get DML based output for it.
It turns a method name into a MethodDesc. Here is an example for a method:
it-CH
it-ch
it-IT
it-it
iu+-,
IUnknown pointer:           %p
IUnknown V-table pointer :  %p (captured at RCW creation time)
j Y;E
j!h@r
j%Zf9
j,hPh
j:Xf;
j:Zf;
j][f;
j]Yf9
J>f;O
j0Xf;
j0Yf;
j0Zf;
j1PQW
jA_f;
ja-jp
ja-JP
January
jAXf;
jAZjX
-jd_;
jGYf;
jgYjG
Jit code heap:
JIT Compilation
JITTED %S!%S
JITTED Code Address: %s
JITTED Code Address: 03ef00b8
jjjjj
jjjjjjjj
Jupiter ref count: %d%s%s%s%s
j-Xf;
jXXf;
j-ZCf
jZXf;
ka-ge
ka-GE
Kernel CPU time   : %d days %02d:%02d:%02d.%02d
kernel32
KERNEL32.dll
kernel32.dll
Kernel32.dll
kk-KZ
kk-kz
kn-in
kn-IN
kok-in
kok-IN
ko-kr
ko-KR
ky-KG
ky-kg
-l parameter can be used to show information on local variables in a frame.
L0_0g0r0}0
l3p3t3x3
Large
Large        2,461,696     16,703,488     11,956,224          3     35,868,672
Large        6,303,744    974,778,368    169,089,706         12  2,029,076,472
Large object heap starts at 0x%p
Large object heap starts at 0x01a71000
last GC before OOM
Last good object: %p
Last good object: %p.
Last good object: %s
Last good object: 00a73d14
Last good object: 01EE60C4.
LCMapStringEx
LCMapStringW
ldarg
ldarg.0
ldarg.1
ldarg.2
ldarg.3
ldarg.s
ldarga
ldarga.s
ldc.i4
ldc.i4.0
ldc.i4.1
ldc.i4.2
ldc.i4.3
ldc.i4.4
ldc.i4.5
ldc.i4.6
ldc.i4.7
ldc.i4.8
ldc.i4.m1
ldc.i4.s
ldc.i8
ldc.r4
ldc.r8
ldelem
ldelem.i
ldelem.i1
ldelem.i2
ldelem.i4
ldelem.i8
ldelem.r4
ldelem.r8
ldelem.ref
ldelem.u1
ldelem.u2
ldelem.u4
ldelema
ldexp
ldfld
ldflda
ldftn
ldind.i
ldind.i1
ldind.i2
ldind.i4
ldind.i8
ldind.r4
ldind.r8
ldind.ref
ldind.u1
ldind.u2
ldind.u4
ldlen
ldloc
ldloc.0
ldloc.1
ldloc.2
ldloc.3
ldloc.s
ldloca
ldloca.s
ldnull
ldobj
LDR_DATA_TABLE_ENTRY
ldsfld
ldsflda
ldstr
ldtoken
ldvirtftn
leave
leave.s
LeaveCriticalSection
leaving both threads with no option but to wait forever in the second lock 
Legal to Join
Legal_policy_statement
LegalCopyright
Length
-length
Let the program run, and it will stop with the notice
LF_ALWAYS
LF_APPDOMAIN
LF_ASSERT
LF_BCL
LF_CLASSLOADER
LF_CODESHARING
LF_CORDB
LF_CORPROF
LF_DBGALLOC
LF_EEMEM
LF_EH
LF_ENC
LF_GC
LF_GCALLOC
LF_GCINFO
LF_GCROOTS
LF_IJW
LF_INTEROP
LF_JIT
LF_LOADER
LF_LOCKS
LF_MARSHALER
LF_METADATA
LF_REMOTING
LF_SECURITY
LF_STARTUP
LF_STORE
LF_STUBS
LF_SYNC
LF_THREADPOOL
LF_VERIFIER
LF_ZAP
lifetime of your application, you may have a GCHandle leak. This will cause   
Lightweight function
like:
limited to, "[DEFAULT]", "[C]", "[STDCALL]", "[THISCALL]", and so on.  The second
Line number must be positive
line number. The -n (No line numbers) parameter can be specified to disable 
-lines
-lines command line argument.
-list
list too long
listnearobj
ListNearObj
-live
-live     Only print live objects
Live debugging session required
-live:     optional. Only print threads associated with a live thread.
load of mscordacwks.dll.  .cordll -ve -u -l will do a verbose reload.
load the matching version of SOS for the version of CLR you are debugging.
Loaded %S
loaded from an assembly store (such as a SQL db) rather than disk, the
loaded from.
loaded in the process. You shouldn't attempt to use a version of SOS.DLL that 
loaded managed module. <module name> can also be the debugger's name for a 
-loader
Loader Heap:
LoaderCodeHeap:    
LoaderHeap:              %p
LoaderHeap: 001cab3c
LoadLibraryA
LoadLibraryExW
LoadResource
local_%d
LocaleNameToLCID
localloc
LOCALS:
LOCALS: (none)
LockResource
log entry, and the fourth contains the log message. The facility field is 
log, you would probably want the Shared Source CLI to find out exactly where 
log10
long-lived objects eventually get "promoted" to generation 2.
low on ephemeral space
Low on memory during GC
LowFrequencyHeap:  
LowFrequencyHeap:   %p
LowFrequencyHeap:008f0000(00002000:00001000) Size: 0x00001000 bytes.
LowFrequencyHeap:00900000(00002000:00001000) 03ee0000(00010000:00003000) Size: 0x00004000 bytes.
LowFrequencyHeap:00920000(00002000:00001000) 03e30000(00010000:00003000) Size: 0x00004000 bytes.
lt-lt
lt-LT
lv-lv
lv-LV
m_code
m_debugString
m_handle
m_resolver
m_runtimeType
m_scope
m_tokens
m_value
m_valuetype is a value type. The value in the MT column (0090320c) is the 
M0K0I
M0S0k0
make sense of it. You would usually come to use it if you suspect a gc heap 
make sure you have valid symbols.
managed exception(s), if any, on each managed thread. If you do see an 
Managed object:             %s
Managed object:    %s
managed objects. It is important to keep track of this information, because if 
Managed OOM occured after GC #%d (Requested to allocate %d bytes)
Managed OOM occured after GC #12 (Requested to allocate 100000 bytes)
Managed OOM occured after GC #28 (Requested to allocate 1234 bytes)
Managed ref count:          %d
managed thread. You can run !threads to get a list of managed threads in
Managed to Unmanaged transition
-ManagedExcepStack
Management of the list of pending breakpoints can be done via !BPMD -list,
map/set too long
Mapped
MapViewOfFile
March
-max      Ignore objects larger than the size given in bytes
MAXIMUM
may be some noise in this output, as an unmanaged application may be storing  
MDArray
mdToken:
mdToken:         %p
mdToken:      %p
mdToken:      0600000d
mdToken: 0600000b
mdToken: 0600000d
Medium
Medium         139,264        528,384        337,920          4      1,351,680
Medium         249,856      1,019,904        521,557          6      3,129,342
Member (mdToken token) of
MemberRefToDescMap:      %p
MemberRefToDescMap: 03ec00e8
Memory
Memory Availability (Numbers in MB)
memory for any references to the Strong and Pinned GCHandles in the process, 
memory in that range, you'll see the object pointers that are registered:
memory scan with Control-C or Control-Break.                                   
merged pins
Message
Message:          
MetaData start address:  %p (%d bytes)
MetaData start address: 0040220c (1696 bytes)
MetaData start address: 00402230 (1888 bytes)
METHOD
method 
Method info block:
method might correspond to a "mov edi,ecx" statement.
method name from the metadata, or from the output of the "!dumpmt -md" command. 
Method Name:  %S
Method Name:  Mainy.Main()
Method Name: MainClass.Main()
Method Name: Mainy.Main()
method of my application. How can I do this?"
Method Table:    %s
method. For example, the notation "reg EDI becoming live" at offset 0x11 of the
MethodDefToDescMap:      %p
MethodDefToDescMap: 03ec0064
MethodDesc
MethodDesc = %p
MethodDesc Table
MethodDesc. Here is an example showing class tokens being resolved:
MethodDesc:   %s
MethodDesc:   00902f40
MethodDesc:  %s
MethodDesc:  <not loaded yet>
MethodDesc: 00902f40
MethodDesc: 03310f68
methods of finding the AppDomain failed. Try running
methods, !bpmd will set a breakpoint for all of them.
MethodTable 0090320c
MethodTable for it, and the Value column provides the start address:
MethodTable:  %s
MethodTable:  009032d8
MethodTable: %s
MethodTable: <not loaded yet>
MethodTable: 009032d8
MethodTable: 0090375c
MethodTable: 009038ec
MethodTable: 0331121c
MethodTable: 03e41044
MethodTable: 11a47ae0
Microsof
Microsoft
Microsoft Code Signing PCA 2011
Microsoft Code Signing PCA 20110
Microsoft Corporation
Microsoft Corporation0
Microsoft Corporation1
Microsoft Corporation1&0$
Microsoft Corporation1(0&
Microsoft Corporation1)0'
Microsoft Corporation1200
Microsoft NTSD extension for .NET Runtime
Microsoft Time-Stamp PCA 2010
Microsoft Time-Stamp PCA 20100
Microsoft Time-Stamp Service
Microsoft Time-Stamp Service0
might keep a 50 Megabyte array alive because a strong GCHandle points to it,
might store the handle in a strange way (shifting bits, for example).
-min      Ignore objects less than the size given in bytes
minidumpmode
MinidumpMode
Minidumpmode
Minidumps created with ".dump /m" or ".dump" have a very small set of 
MINIMUM
minimum set of SOS debugging commands to work. At this time, those commands 
minkernel\crts\ucrt\inc\corecrt_internal_strtox.h
mi-nz
mi-NZ
Missing CCW address
Missing EEClass address
Missing MethodTable address
Missing quote in %s
Missing RCW address
Missing value for option %s
mk-MK
mk-mk
mkrefany
ml-IN
ml-in
MM/dd/yy
mn-mn
mn-MN
Mode must be 0 or 1
Module %s: 
Module 001c03f0: Size: 0x00000000 bytes.
Module 001c03f0:Size: 0x00000000 bytes.
Module 001c1320: Size: 0x00000000 bytes.
Module 001c1320:Size: 0x00000000 bytes.
Module 001caa38: Size: 0x00000000 bytes.
Module 001caa38:03ec0000(00010000:00002000) Size: 0x00002000 bytes.
Module 5ba22410: Size: 0x00000000 bytes.
Module 5ba22410:Size: 0x00000000 bytes.
module containing the method being examined, the output of the command will
Module does not have base address
module id, then that pending breakpoint is specific to function in that 
Module in 
Module Lookup Table heaps:
module name will look like this:
Module Thunk heaps:
module, such as mscorlib or image00400000.
Module:
Module:          %s
Module:       %s
Module:       001caa38
Module:      %s
Module: 001caa38
Module: 001caa78
Module: 001e2fd8
Module: 10f028b0 (price, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null)
Modules. For example:
Monday
more complex. You need to make sure the mscordacwks.dll file that came with
More than %d heap segments, there must be an error
more useful aspects is that it will format the _stackTrace field, which is a 
movt 
movw 
mr-in
mr-IN
ms-BN
ms-bn
mscordac
mscordaccore
mscordacwks
mscordbi
mscoree.dll
mscorlib or image00400000.
ms-my
ms-MY
-mt       List only those objects with the MethodTable given
MTA Interfaces to be released: %d
MTA Interfaces to be released: 0
mt-MT
mt-mt
mul.ovf
mul.ovf.un
MultiByteToWideChar
multiple AppDomains.
multiple processors, you can expect to see a GC Heap of 400MB or more. The 
Must pass a valid expression
n %zd 1 %zd %zd
n(Finalizer) 
N0L0J
name and a stack frame number are specified in the command line, CLRStack will show 
Name:
Name:               
Name:               %S
Name:               Unknown
Name:        %S
Name:        %S[
Name:       %S
Name:      %S
Name:      Shared Domain
Name:      System Domain
Name: Bank
Name: C:\pub\unittest.exe
Name: Customer
Name: Funny
Name: MainClass
Name: MainClass.Main()
Name: Mainy
Name: Price
Name: unittest.exe
Name: Value[]
name2ee
Name2EE
Name2EE                            FindRoots
NAN(IND)
nan(ind)
nan(snan)
NAN(SNAN)
native int
native uint
nb-NO
nb-no
negatives because a user is free to pass that GCHandle to unmanaged code that 
-nested
Nested exception -------------------------------------------------------------
newarr
newobj
NEWVALUE
Nhttp://www.microsoft.com/pkiops/crl/Microsoft%20Time-Stamp%20PCA%202010(1).crl0l
Nj)[f9
nl-be
nl-BE
nl-NL
nl-nl
nn-NO
nn-no
No CCW pointer specified
No duplicate promote or relocate messages found in the log.
No EH info available
No GC info available
no gc mode
No heap corruption detected.
no memory for a new seg
No Stress log in the image, GCHist commands unavailable
No Stress log in the image, no file written
-nofields
-nofields has no effect unless -details is specified
-nofields:     do not print fields of the object, useful for objects like 
-nofuturemodule
NoName
non-static values won't because you need an instance of an object for that.
Normal JIT generated code
Normal JIT:03ef0000(00010000:00002000) Size: 0x00002000 bytes.
-nostacks
Not a managed object
Not a valid exception object
not a valid MethodDesc
Not all SOS commands support DML output.
Not an array, please use !DumpObj instead
Not calculated
Not enough memory to read IL
Not jitted yet
Not JITTED yet.
Not JITTED yet. Use !bpmd -md %p to break on run.
Not JITTED yet. Use <exec cmd="!bpmd -md %p">!bpmd -md %p</exec> to break on run.
Not supported on mini dumps.
Note that !PrintException with no parameters will print out the last thrown
Note that CLR keeps track of which RCWs are bound to which managed objects through
Note that dynamic IL is constructed a bit differently. Rather than referring
Note that fields of type Customer and Bank are themselves objects, and you can 
Note that the Thread could have transitioned between
NOTE:
NOTE: THIS FILE CONTAINS SOS DOCUMENTATION. THE FORMAT OF THE FILE IS:
Notes
notification will cause a break in the debugger:
November
ns-za
ns-ZA
ntdll
ntdll!KiUserExceptionDispatcher
ntdll.dll
NtQueryInformationProcess
Number of characters requested: %d
Number of GC Heaps: %d
Number of GC Heaps: 1
Number of IFaces in IFaceMap:
number of roots can share a common subgraph, and that part will be reported in 
Number of Timers: %d
NumInstanceFields:   %x
NumStaticFields:     %x
NumThreadStaticFields: %x
o 0x%p %zd %zd 
O0M0K
object
Object
object
object %#p does not have valid method table
object %#p is a valid object
Object %p has no generation
Object %p is misaligned.
object %s contains free object %p at %p
Object %s contains free object %p at %p.
Object %s has a bad GCDesc.
Object %s has an invalid method table.
Object %s is too large.  End of segment at %p.
Object %s will survive this collection:
Object %s: %s missing card_table entry for %p
object %s: bad member %p at %p
Object %s: Bad member %p at %p.
Object %s: Failed to read members.
Object %s: Size %d is too small.
object %s: size %d too small
object %s:%s missing card_table entry for %p
Object %s:%s missing card_table entry for %p
object 00a73d24: does not have valid MT
object 01ee60dc: bad member 00000003 at 01EE6168
object 0x28000ec does not have valid method table
object 0x680017c: bad member 00000001 at 06800184
object and corrupt it:
Object header for %p should have a SyncBlock index of %d.
object in question. ThinLocks will not be reported by the !SyncBlk command. 
Object Inspection                  Examining code and stacks
object is not referenced by any "proper" root it may still be referenced by an 
object which correspond to the return value and parameters:
objects ready for finalization are also included in the statistics (if any).
objects through the !SyncBlk command.  You can find more information about RCW
Objects with Finalizers are the easiest case, as the CLR needs to be able to 
objects, such as a managed cache in a web server.
objects, there is a -nostacks option.
ObjSize
objsize
ObjSize                            CLRStack
obwQ4
October
OD_^]
of any objects pointed to by those handles. In calculating object size, 
of GC relocations that may have led to the address passed in as an argument.
of mscordacwks.dll, with names like mscordacwks_<architecture>_<version>.dll
of sos.dll functionality will be available. If needed, attaching to the live
of the signature.
of value classes, while others do not.
of work requests in the queue, number of completion port threads, and number of
Offset
offset
offset 
OjlZ;
Older Generation:
older generations::Root:  068012f8(AAA.Test+a)->
older object (from an older generation), from a generation that has not yet been 
ole32.dll
on by default because very often in a debugging scenario, you are 
On x64 platforms, Transition Frames are not displayed at this time. To avoid
once you have the EEClass, you can run !DumpClass, which will display the
one is if the process is running out of VM space to reserve a segment; the other
One would issue the following commands to set breapoints on G3.F() and 
ones are discussed below:
only for that frame (provided you specify -l or -p or -a of course). If a variable 
only read %x bytes at %p
onto large amounts of memory it does not provide information regarding the 
OOM exceptions could be because of the following reasons:
OpenVirtualProcess2
OpenVirtualProcessImpl
operator
operator "" 
operator co_await
operator<=>
option on to protect against running unsafe commands against small minidumps.
or is old (discarded) data. You would have to use !CLRStack and !U to 
or the module is loaded, but the function is not jitted yet. In these cases,
OriginalFilename
OS Thread Id: 0x%x 
other forms has occurred.  Now the debuggee is in the right state for 
Other Handles:
Other mechanisms enabled
Out of memory
out of memory
Outer IUnknown:    %p
Outer, the bpmd command would become:
Outer+ExplicitItfImpl, using the '+' separator, while the method name
OutOfMemoryException exception you can use the !PrintException command on it.
output is the return value (in this case a "void").  Finally, the method's arguments
output of !Threads into !ThreadState.
output to "interesting" threads only, which is defined by
Page File         %8d     %8d
PagefileUsage:  %8d KB       PeakPagefileUsage:  %8d KB
pa-in
pa-IN
param_%d
parameters.
PARAMETERS:
PARAMETERS: (none)
Paremeters:
Parent Class:    %s
Parent Domain:      %s
Parent Domain: 0014f000
particular loaded module. If the pending breakpoint has a zero module id, then
particular managed exception, say a System.OutOfMemoryException, but continue
particular types, restrict to a range, or look for ThinLocks (see !SyncBlk 
particularly in the area of PInvoke/Interop. Adam Nathan has written some great
passed directly to !DumpStack. The -short option tries to narrow down the 
path is pointing to clr.dll as well.
pathto
PathTo
PDB symbol for clr.dll not loaded
PEB_LDR_DATA
PEFile 
PendingThread:
-perdomain
Phttp://www.microsoft.com/pkiops/certs/Microsoft%20Time-Stamp%20PCA%202010(1).crt0
Physical Memory   %8d     %8d
Pinned
pinned
PINNED 
pinned 
Pinned Handles:
places:
Please ensure that %S is on your symbol path.
Please note the -aggregate parameter to !ObjSize has been removed.  Please see
Please provide the -addr argument for the address of the stress log, since no recognized runtime is loaded.
pl-pl
pl-PL
pointer for the method, or a code address within the method body. Unlike the
pointer if provided.
pointer in the output can be passed to !DumpModule. Any AppDomain pointer can 
Pointer table:
portion of the output is either "[hasThis]" or "[explicit]" for whether the method
positives. If you still suspect a leak, use this function over time to        
possibility is eliminated, consider contacting Microsoft Product Support for
Possible thread states:
post pin
post short
post short padded
PP9E u:PPVWP
PPh80
PPhX0
PPPPP
PPPPPPPP
PPPPPWS
PQRVhX,
PQSVW
PQVhT-
pre and post pin
pre pin
pre short
pre short padded
Preemptive
prefix1
prefix2
prefix3
prefix4
prefix5
prefix6
prefix7
prefixref
PreJIT
preJIT generated code
Presents an annotated disassembly of a managed method when given a MethodDesc
prev_obj_addr + prev_obj_size = arg_addr && arg_obj + arg_size = next_obj_addr
prev_obj_addr + prev_obj_size = next_obj_addr
prevent the garbage collector from moving an object during collection. These 
PREVVALUE
price, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
print
PrintException
printexception
PrintException
Printexception
PrintException (pe)                EHInfo
prints the type name and MethodTable they refer too. Sample output:
Private
PrivateBuild
Process Memory
process or debugging a full dump will allow access to sos.dll's full feature
Process Started at: %4d %s %2d %d:%d:%d.%02d
Process Times
process. It enumerates each Assembly loaded into those AppDomains as well. 
ProcessParameters
ProcInfo
procinfo
ProductName
ProductVersion
ProfilingAPIAttach 
ProfilingAPIDetach 
programs. Functions are listed by category, then roughly in order of
programs. The -p parameter will show arguments to the managed function. The 
Prolog size: 
promote/reloc records in error 
Promoted?
Promotes
promoting GCs
Promotion for root %p (MT = %p)
Protect
protection applied to that memory (free, reserved, committed, private, mapped, 
Provides a summary view of the virtual address space, ordered by each type of 
provides a warning about fragmentation:
PRQWhp1
PSAPI.DLL
Pseudo-register number must be between 0 and 19
PSh0K
PSP slot: 
PSPSym: 
PSQhXK
PSSPRQh
PSVhh
pt-BR
pt-br
pt-PT
pt-pt
public class ExplicitItfImpl : I1
public class ExplicitItfImpl<U> : IT1<U>
public class G1<T> {
public interface I1
public interface IT1<T>
public void F(T1 p1, T2 p2, T3 p3)
push 
PVh4-
PVhD(
PVhd(
PVWhL
PWhh`
q\Q17
Q9N$u
QEX82q'
QPQPh
QQh80
QQSVW
QQSVWd
QQSWj0j@
QSVWh
QueryPerformanceCounter
question:
Quitting at %p due to user abort
quz-BO
quz-bo
quz-ec
quz-EC
quz-pe
quz-PE
QVWSj
qword ptr [
qword ptr ds:[
R$;Q,r
r$;r u
r$t%zd=0
r$t%zd=1
r_f;M
r`f;M
r`f;U
R0P0N
RaiseException
RandomMove
RCW             %d
RCW is cleaned up.  If you are trying to debug an issue related to one of these
RCW:         %s
RCWCleanupList
rcwcleanuplist
Rcwcleanuplist
RCWCleanupList                     VMStat
RCWs, then you can use the !RCWCleanupList function to display which COM objects
ReadConsoleW
ReadFile
readonly.
ReadVirtual failed with code hr = %x.
Ready for finalization %d objects 
Ready for finalization 0 objects (0015bca0->0015bca0)
READYFORMANAGEDCODE
Reason: %s
Reason: Didn't have enough memory to allocate an LOH segment
Reason: Didn't have enough memory to commit
receive news of module loads and JITs, at which time it will try to resolve 
Redmond1
Ref Count Handles:
Ref count:         %d%s
ref counted
refanytype
refanyval
RefCounted
RefCounted Handle: %p%s
reference count:
Reference found in stress log will be ignored
reference the object:
reference to the underlying COM object is no longer needed, the corresponding
reference. This might be a stack address or a field within an object, for 
Reflection 
-refs
ReJITed versions:
Relocation %s for root %p
Relocs
rem.un
Reported Dead
reported frame register
reported invalid pointer
reported pointer relative to wrong base register
reported register in caller's frame
Reserve
Reserve:
ResetEvent
restrict(
rethrow
Return Kind: %s
reused seg with best fit
reused seg with normal fit
Rich@
rMf;M
Root %p promoted multiple times in gc %d
Root %p relocated multiple times in gc %d
root specified as the argument.
Roots
roots (You can use !GCRoot to find out). The statistics section provides a 
roots are keeping it alive. Or you can find all objects of that type with 
ro-ro
ro-RO
RPSQW
RPVQS
rqf;M
RQh4h
RQPh\?
RtlUnwind
run !DumpObj on them too. You could look at the field directly in memory using
run against a minidump.
running "!DumpArray %p".
running if other exceptions are thrown. The command can be used in two ways:
RuntimeCallableWrappers (RCW) to be cleaned:
ru-ru
ru-RU
rvf;M
rvf;U
RVSWh
S0Q0O
Safe critical
sa-IN
sa-in
same directory as the main CLR dll (CLR.DLL). Newer versions of the 
Sample output for a field:
Sample output for a method:
Sample output:
Saturday
savemodule
SaveModule
SByte
sc;~<r^w
Scalar
scan wouldn't be able to find those.                                          
scheduled for collection.  At this point !FindRoots will search those older 
scj@j
sdj@j
searches.
Searching %p...
Searching memory
section %d - VA=%x, VASize=%x, FileAddr=%x, FileSize=%x
section 0 - VA=1000, VASize=e82da9, FileAddr=400, FileSize=e82e00
section 1 - VA=e84000, VASize=24d24, FileAddr=e83200, FileSize=ec00
section 2 - VA=ea9000, VASize=5a8, FileAddr=e91e00, FileSize=600
section 3 - VA=eaa000, VASize=c183c, FileAddr=e92400, FileSize=c1a00
Security
Security object: 
SecurityDescriptor: %p
SecurityException Message: 
See "!help bpmd" for more details.
see that only generation 0 (the youngest generation) has any objects registered
See the documentation for !DumpStack for more info.
se-fi
se-FI
segment
se-no
se-NO
September
Server mode with %d gc heaps
se-se
se-SE
SetEndOfFile
SetEvent
SetFilePointer
SetFilePointerEx
SetLastError
SetStdHandle
Setting breakpoint: %s [%S]
SetUnhandledExceptionFilter
sgj@j
shared
Shared
Shared Domain
Shared Domain:      %s
Shared Domain: 5e066970
short
-short
-short    Limits output to just the address of each object. This allows you
-short    Limits the output to just the address of each object.  If used in 
should be used sparingly, and for short periods of time. If you don't follow 
should only need to execute "!CLRStack -i", and from there, click on the DML 
show the mapping between metadata tokens and types/methods in a friendlier way. 
shr.un
Shutdown 
ShutdownHelper 
signature itself.  By trial and error you should be able to find various elements
signature that has been corrupted in some manner you can use !DumpSigElem to read out 
signed byte
signs of corruption. It walks objects one by one in a pattern like this:
similar to !DumpObj. Although static field values will be displayed, 
Simple Context information:
Single
Size of parameter area: %x
Size:        %d(0x%x) bytes
Size:        %I32d(0x%I32x) bytes
Size: 0x%I32x (%I32lu) bytes
Size: 132(0x84) bytes
Size: 20(0x14) bytes
Size: 28(0x1c) bytes
Size: Expected '0x%x', Actual '0x%x'
sized ref
SizedRef
SizedRef Handles:
sizeof
sizeof(%p) = %d (0x%x) bytes (%S)
sizeof(00a79d40) =      152 (    0x98) bytes (Customer)
SizeOfImage
Skipping allocation context: [%#p-%#p)
sk-SK
sk-sk
SleepConditionVariableCS
Slots in VTable:
sl-SI
sl-si
Small
Small            4,096         65,536         43,957         41      1,802,237
Small            4,096         65,536         48,393         27      1,306,611
sma-NO
sma-no
sma-SE
sma-se
smj-no
smj-NO
smj-SE
smj-se
smn-FI
smn-fi
sms-FI
sms-fi
snan)
SNAN)
So the total size of the GC Heap is only 72K. On a large web server, with 
SOH:%3d%% LOH:%3d%%
Some functionality may be impaired
Some handles were not found. If the number of not-found handles grows over the
Sometimes the  source of a memory leak is a GCHandle leak. For example, code
SOS can't retrieve local names at this time, so the output for locals is in
SOS error: GetClrModuleImages failed hr=0x%x
SOS error: IXCLRDataModule->GetFileName failed hr=0x%x
SOS Error: Out of memory
SOS Error: Unable to CoCreateInstance class=CLSID_CorSymBinder_SxS, interface=IID_ISymUnmanagedBinder3, hr=0x%x
SOS Error: Unable to get symbol path length. IDebugSymbols3::GetSymbolPathWide HRESULT=0x%x.
SOS Error: Unable to get symbol path. IDebugSymbols3::GetSymbolPathWide HRESULT=0x%x.
SOS Error: Unable to query IDebugSymbols3 HRESULT=0x%x.
SOS failure
SOS failure!
SOS is a debugger extension DLL designed to aid in the debugging of managed
SOS Version: %u.%u.%u.%u
SOS Warning: Loading symbols for dynamic assemblies is not yet supported
SOS warning: No symbols for module %S, source line breakpoints in this module will not bind hr=0x%x
SOS.dll
SOS.DLL:
SOS.pdb
SOS: Failed to register callback events
SOS: warning, optimizations for this module could not be surpressed because an optimized prejitted image was loaded
SOS: warning, optimizations for this module could not be surpressed hr=0x%x
SOS: warning, prejitted code optimizations could not be changed at this time. SetDesiredNGENCompilerFlags hr = 0x%x
SOS: warning, prejitted code optimizations could not be changed at this time. This setting is fixed once CLR starts
SOS: warning, prejitted code optimizations could not be changed. Failed to load ICorDebug HR = 0x%x
SOS: warning, prejitted code optimizations could not be changed. GetDesiredNGENCompilerFlags failed hr=0x%x
SOS: warning, prejitted code optimizations could not be changed. This CLR version doesn't support NGEN
SOS: warning, prejitted code optimizations could not be changed. This CLR version doesn't support the functionality
sosflush
SOSFlush
Source file:  %s @ %d
Source file:  c:\Code\prj.mini\exc.cs @ 39
SP/REG  Object   Name
space there is in each generation on each heap.  If the -inclUnrooted option is
-special
Special thread information is not available in mini dumps.
Special thread type
-special:  optional. With this switch, the command will display all the special
specified in the command line, CLRStack will show you the parameters and/or locals 
specified the report will include information about the managed objects from the
Specifying -short will inhibit any display related to SyncBlocks or RCWs.
sq-al
sq-AL
sr-BA-Cyrl
sr-ba-cyrl
sr-BA-Latn
sr-ba-latn
SRQPh
sr-SP-Cyrl
sr-sp-cyrl
sr-SP-Latn
sr-sp-latn
SSh80
SSSSS
SSVWh 
STA Interfaces to be released: %d
STA Interfaces to be released: 1
Stabilizing
stack
Stack Crawl Needed
Stack walk complete.
stack, check the AppDomain of that stack with !threads.
StackTrace (generated):
StackTraceString: 
Stage:              %s
starg
starg.s
Start
-start
start     Begin listing from this address
start    end        module name
Start    Stop     Length    AllocProtect  Protect       State    Type
Start index out of range
start. If you pass the "-MD" flag, you'll also see a list of all the methods 
-startAtLowerBound 
Starvation
-stat
-stat     Restrict the output to the statistical type summary
State
statement will set MyObject to be owned by the current thread. A SyncBlock will
statement. !SyncBlk will detect this with the following output:
static
static public void G<W>(W w)
Statistics for all finalizable objects (including all objects ready for finalization):
Statistics for all finalizable objects that are no longer rooted:
Statistics:
stelem
stelem.i
stelem.i1
stelem.i2
stelem.i4
stelem.i8
stelem.r4
stelem.r8
stelem.ref
stfld
stind.i
stind.i1
stind.i2
stind.i4
stind.i8
stind.r4
stind.r8
stind.ref
stloc
stloc.0
stloc.1
stloc.2
stloc.3
stloc.s
stobj
Stoponexception
stoponexception
StopOnException
Stress log address = 0x%p
Stress log in module 0x%p
STRESS LOG:
StressLog TaskSwitch Marker
StressLog.txt
StressLogSize is the size in bytes of the in-memory log allocated for each 
strike: Failed to store segment
string
String
string
STRING %x
string too long
String Value
String:      
String[100]" actually creates a System.Object array, but it can only hold
StringFileInfo
-strings
-strings  Restrict the output to a statistical string value summary
strong
Strong
Strong and Pinned GCHandles are reported at this time. You can safely abort the
Strong Handles:
struct
struct, and lives on the stack or within an Object on the GC heap. You need
structure and need to know what its contents are.
structures from the stress log saved in the debuggee.  This is achieved by the 
stsfld
StubHeap:          
StubHeap:           %p
StubHeap:008fa000(00002000:00001000) Size: 0x00001000 bytes.
StubHeap:0090a000(00002000:00001000) Size: 0x00001000 bytes.
StubHeap:0092a000(00002000:00001000) Size: 0x00001000 bytes.
sub.ovf
sub.ovf.un
succeeding the address passed in:
SUCCESS: GCHist structures initialized
SUCCESS: Stress log dumped
Summary
Summary          4,096     16,703,488        816,005         50     40,800,250
Summary          4,096    974,778,368     47,249,646         43  2,031,734,778
-summary" debugger command will show you the largest free region in the VM. For
Sunday
SupportsIInspectable 
SupportsUpdateableMethods
Suspend Unstarted
SuspendEE 
sv-fi
sv-FI
sv-SE
sv-se
SVW8A
SVWj@
SVWj`
SVWj8
SVWj8j
SVWjA_jZ+
SVWjHj
SWhh!
switch
SwitchToFiber
SWj`j
sw-ke
sw-KE
SWShX
sxe %s "!soe %s %s %zd;.if(@$t%zd==0) {g} .else {.echo '%s hit'}" %x
sxe -c "!HandleCLRN" clrn
symbols for the managed module containing the given <code address>, and if the 
SymFindFileInPath failed for %S. HRESULT=0x%x.
SymFindFileInPathW
Sync Suspended
syncblk
SyncBlk
SyncBlk                            HeapStat
SyncBlock
SyncBlock %d corrupted, points to invalid object %p
SyncBlock %d is invalid%s
SyncBlocks to be cleaned by the finalizer thread:
SyncBlocks to be cleaned up: %d
SyncBlocks to be cleaned up: 0
syr-SY
syr-sy
System
System Domain
System Domain:      %s
System Domain: 5e0662a0
System.__ComObject class, and when objects of this type are collected, and a
System.Enum
System.Object
System.Object arrays that are constrained to contain Strings. ("new 
System.RuntimeType
System.RuntimeType+RuntimeTypeCache
System.Security.SecurityException
System.String object pointers). You can use -type in a special way to find
System.ValueType
SystemTimeToTzSpecificLocalTime
SZArray
SZARRAY
t %zd 0 %S
t hxv
t SWP
t!hhD
t!Wh0
t"hxv
t#Vh\ 
t#WVR
t$$hd)
T$<UVW
t$4hD'
t&PVS
t*;O`u
t*h 3
t,h@r
t.RSPW
t+;~4r2
t0jXXf
t1Gf;
t2RQh
t4SWV
t5;_4r?w
t5x5|5
tail.
ta-in
ta-IN
take the MethodTable pointer in the MT column, and the Value and pass them to 
Task Reset
Task was switched from %x
TEB information is not available so a stack size of 0xFFFF is assumed
te-in
te-IN
TerminateProcess
Thales TSS ESN:F87A-E374-D7B91%0#
that can provide full or partial output are:
That indicates a serious problem. See the help for !VerifyHeap for more 
that install is on your symbol path, and you need to load the corresponding
that is locked by a thread. In version 2.0 of the CLR and above, a mechanism 
that log out to a file. If no Filename is specified, the file "Stresslog.txt" 
that precept, the gc heap can become very fragmented.
That said, if a serious leak is going on, you'll get a ever-growing set of 
that shows up in a run of !Threads.
that the Windows Debugger can load. If you have the correct symbol path to the
That will load the SOS extension DLL from the same place that CLR.DLL is 
The !AnalyzeOOM command aims to help you with investigating 1) which is the most
the !FindRoots command:
The !Threads command outputs, among other things, the state of the thread.
The "-gen" form causes the debugger to break in the debuggee on the next 
the "size" is displayed as 0:
The "Source line" output will only be present if the debugger can find the 
The abbreviation !do can be used for brevity.
The abbreviation !dso can be used for brevity.
The abbreviation !pe can be used for brevity.
The actual offsets that you should add are determined by the contents of the
the address of the signature:
The APT column gives the COM apartment mode. 
The arguments in detail:
The base address of an image can be found with the "LM" debugger command:
the breakpoint applies to modules that have not yet been loaded. Use 
The column VT contains the value 1 if the field is a valuetype structure, and
the command !DumpVC.
The command !FindRoots can only be used after the debugger stopped on a CLRN GC notification.
The command considers the heap as "locally consistent" if:
The command has diagnostic output which doesn't need to be repeated here. One 
The command looks for the address in the GC heap that looks like a valid 
the current AppDomain for each thread.
the current stack. Combined with the stack tracing commands like K and 
The current thread is unmanaged
the debugger must be configured to load the line number information from
The -derived option will cause StopOnException to set the pseudo-register to
The diagnostic output indicates that the operation was successful. If 
The Domain column indicates what AppDomain the thread is currently executing
The EEClass is a data structure associated with an object type. !DumpClass 
The elements of this signature can be obtained by adding offsets into the signature
The first column is the OS thread ID for the thread appending to the log, 
The first command is "contents" which is the general help screen. The rest 
The first section of the output is the calling convention.  This includes, but is not
the fly. Happily it works for non-dynamic code as well.
the format <local address> = <value>. The -a (all) parameter is a short-cut
the freachable queue of the finalizer. Some caution about the stack roots: 
the function to a breakpoint. -nofuturemodule can be used to suppress 
The garbage collector data structures are not in a valid state for traversal.
the GC heap (in Server GC it displays OOM, if any, on each GC heap). 
The GC heap is divided into generations, and objects are listed accordingly. We
the GC Heap to grow larger as objects are being kept alive, referenced only   
the handle in a non-standard way, perhaps with some bits flipped. The memory  
The -i option is a new EXPERIMENTAL addition to CLRStack and will use the ICorDebug
The -i options uses DML output for a better debugging experience, so typically you
The information for the Garbage Collector lists the ranges of each Segment in 
The last form of this command is meant to be used after the break caused by the 
the latter scenario you can look at the "Memory\% Committed Bytes In Use" see
The loader output lists various private heaps associated with AppDomains. It 
the log comes from.
The log facilities are defined as follows:
the managed heap. This can be useful if you believe you have an object pointer.
The Maps listed map metadata tokens to CLR data structures. Without going into 
the method. You can also obtain this information with the !GCInfo command.
The module you are "browsing" with Name2EE needs to be loaded in the process. 
The module you are "browsing" with Token2EE needs to be loaded in the process. 
The most common handles are "Strong Handles," which keep the object they point 
the offset given. "dd a79d40+8 l1" would allow you to look at the bank field 
The optional argument addr allows one to specify a stress log other then the 
The other cases should be fairly obvious from the callstack.
The output contains all COM interface pointers that the RCW holds on to, which
The output contains the COM reference count of the CCW, which is useful for
the output is very noisy and potentially confusing. The command is good for
The percentage column contains a breakout of free or unrooted bytes to total bytes.
the process
The process of answering the question would go something like this:
The pseudo-register number is optional. If you don't pass a number, SOS will 
The root value obtained from !HistObjFind can be used to track the movement of 
the second column is the timestamp, the third is the facility category for the 
the size of all the roots that reference the subgraph.
the size.
The start/end parameters can be obtained from the output of !EEHeap -gc. For 
the symbol files. Use the ".lines; .reload" command to achieve this.
the SyncBlock of the object.  As such, you can see more information about RCW
The type is declared in the shared domain and other
The user dump currently examined is a minidump. Consequently, only a subset
the valid portions of it.
The version of SOS does not match the version of CLR you are debugging.  Please
The Windows Debugger syntax of <module>!<type> is also supported. You can
then you should replace "clr" with "coreclr".
There are 2 legitimate scenarios where GC would return OOM to allocation requests - 
There are nested exceptions on this thread. Run with -nested for details
there are no objects ready for finalization, presumably because they still have
There are three ID columns: 
There is a new option "-mt", which will display the types defined in a module,
There is no current managed exception on this thread
There is yet one more way to specify a module name. In the case of modules
There was no failure to allocate memory
There was no managed OOM due to allocations on the GC heap
there will be a minimal managed environment for executing SOS commands.
these arrays. Just pass "-type System.String[]" and those Object arrays will
These roots may be false positives.
tHhxv
thing to keep in mind is that anytime you search all of memory for a value, you
-thinlock
ThinLock owner %x (%p), Recursive %x
-thinlock Report on any ThinLocks (an efficient locking scheme, see !SyncBlk 
this behavior.
This brings up a good question: "I want to set a breakpoint on the main
This command allows you to examine elements of an array object.
This command allows you to examine the fields of an object, as well as learn 
This command allows you to take a image loaded in memory and write it to a 
This command dumps a single element of a signature object.  For most circumstances,
This command dumps the signature of a method or field given by <sigaddr>.  This is
This command examines all stress log relocation records and displays the chain 
This command is an aid in tracking down GCHandle leaks. It searches all of 
This command is not supported in a minidump without full memory
This command lists basic information about the ThreadPool, including the number
This command lists information about a COM Callable Wrapper. You can use
This command lists information about a MethodDesc. You can use !IP2MD to turn 
This command lists information about a Runtime Callable Wrapper. You can use
This command lists the objects registered for finalization. Here is output from
This command provides a verbose stack trace obtained by "scraping." Therefore
This command releases any resources used by the Hist-family of commands. 
This command runs !DumpStack on all threads in the process. The -EE option is 
This command shows the generation sizes for each heap and the total, how much free 
This command will display any managed objects it finds within the bounds of 
This command will print a "?" in the domain column if the type is loaded into multiple
This DynamicMethodDesc is not yet JITTED. Placing memory breakpoint at %p
This function allows you to turn a class name into a MethodTable and EEClass. 
This function allows you to turn a metadata token into a MethodTable or 
This function doesn't see much use, especially since a tool like ILDASM can 
This function is important for CLR Devs, but very difficult for anyone else to 
this function, then continue.
This is a bit field which corresponds to various states the thread is in.
This is a deadlock situation, as Thread A could take r1, and Thread B r2, 
This is because a Customer points to a Bank, has a name, and the Bank points to
This is dynamic IL. Exception info is not reported at this time.
This is likely to be a bug in GC
This is often easier than module and method name syntax. For example:
This is to handle the case where objects re-register themselves for finalization.
this log in the process. For example, 20 threads with 524288 bytes per thread 
This makes !SyncBlk useful for detecting managed deadlocks. Consider that the
This means that the CLR is not loaded yet, or has been unloaded. You need to 
This means TypeDef token 2 maps to a MethodTable with the value 0090320c. You 
This prints the Common Language Runtime version. It also tells you if the code 
this problem, and running with Managed Debugging Assistants is advised. If that
This token type is not supported
This usually means the installation of .Net Framework on your machine is missing or needs repair
This will format fields of any object derived from System.Exception. One of the
THREAD
THREAD  TIMESTAMP     FACILITY                              MESSAGE
Thread %3d
Thread %x (%S): %S: %d (0x%x) bytes (%S)
Thread %x:
Thread Abort Requested
thread exits.
thread in the process. In the case above, each thread gets a 64K log. You 
Thread Injection History
Thread Pool Worker Thread
Thread state = a030
ThreadCount:
ThreadOBJ
Threadpool
threadpool
ThreadPool
ThreadPool                         SaveModule
ThreadpoolWorker 
Threads
threads
Threads
threads. It also enumerates all GCHandles in the process, and totals the size 
threadstate
ThreadState
ThreadTimedOut
throw
th-TH
th-th
Thursday
-time
Time stamp: Expected '0x%x', Actual '0x%x'
Timer 
timers.
tLjHR
TlsAlloc
TlsFree
TlsGetValue
TlsSetValue
TLstatic
tn-ZA
tn-za
to a loaded, jitted or ngen'd function it will create a breakpoint with "bp".
To aid in diagnosing hard-to-reproduce stress failures, the CLR team added an 
to alive until the handle is explicitly freed. "Pinned Handles" are used to 
to be fully qualified.
To check the state of the thread, simply pass that bit field from the
To correctly specify explicitly implemented methods make sure to retrieve the
To create a full user dump use the command: .dump /ma <filename>
To examine log entries related to an object whose present address is known one 
To get a type name exactly right, first browse the module with ILDASM. You
To get the full callstack use the "kb" command in the debugger for that thread.
to know the MethodTable address to tell SOS how to interpret the fields, as
to metadata tokens, the IL points to objects in a managed object array. Here
to not optimize functions in the managed app by creating a file myapp.ini 
To see the managed exception(s) use the !Threads command which will show you 
To try again re-issue the !FindRoots -gen <N> command.
To try the command anyway, run !MinidumpMode 0
To turn on the stress log, set the following registry keys under
TODO: Implement GetFrameName
TOKEN %x
Token:       %p
Token: 0x02000002
Token: 0x02000003
Token: 0x02000004
Token: 0x02000005
Token: 0x0600000d
token_0x%8.8X
token2ee
Token2EE
Token2EE                           GCHandleLeaks
too much detail, you can examine memory at those addresses to find the 
Total
TOTAL
Total           %d
Total    %12I32u %12I32u %12I32u %12I32u
Total    132          24           24           80          
Total    307916       0            306196       0           
Total    337556       24           306968       8800        
Total  CPU time   : %d days %02d:%02d:%02d.%02d
Total %d objects
Total 4 objects
Total 5 objects
total 5 objects
total 619 objects
Total LoaderHeap size:   
Total LoaderHeap size: 0x15000(86016)bytes
Total Method Slots:  %x
Total Size   0x1201c(73756)
Total Size  0x5d73a8(6124456)
Total size:      
Total size:        
Total Size:              
Total size: 0x0(0)bytes
Total size: 0x2000(8192)bytes
Total size: 0x3000(12288)bytes
Total size: 0x6000(24576)bytes
Total size: 0x8000(32768)bytes
Total: %d
TotalSize
tQhxv
tr;},sm
tracing roots...
Translation
Transparency:        %s
Transparency: %s
Transparency: Critical
Transparent
Traverseheap
traverseheap
TraverseHeap
TraverseHeap                       BPMD 
Traversing a gc heap failed
tr-tr
tr-TR
Tt.jh^;
Tt1jhZ;
tt-ru
tt-RU
Tuesday
Turn on Managed Debugging Assistants. These enable additional runtime diagnostics, 
turned on, then SOS will output DML by default.  Alternatively, you may leave
tyhxv
-type
TYPE           MINIMUM        MAXIMUM        AVERAGE  BLK COUNT          TOTAL
-type     List only those objects whose type name is a substring match of the 
Type "!help <functionname>" for detailed info on that function. 
Type MT:     %s
Type Name:   %S
type sets breakpoints on all already JIT-ted generic methods and sets a pending 
type:
TYPED
typedbyref
TypedByRef
TypeDef
TypeDefToMethodTableMap: %p
TypeDefToMethodTableMap: 03ec0010
typedref
TypedReference
TypeRef
TypeRefToMethodTableMap: %p
TypeRefToMethodTableMap: 03ec0024
Types defined in this module
types in a module with !DumpModule -mt <module pointer>.
Types referenced in this module
tzSVj
u PSh
u PSh0
u vHj
u!hx5
u.PSh
u:h 1
u:hhw
u0jAXf;
U0S0Q
uBjAYjZ+
uejHQ
uf_^[
uHj`P
uint16
UInt16
UInt32
uint32
uint64
UInt64
uint8
UIntPtr
u-jAXf;
u-jAXj
uk-ua
uk-UA
uLj8P
Unable to build snapshot of the garbage collector state
Unable to decipher generated stack trace
Unable to determine bounds of gc heap
Unable to display fields
Unable to display GC handles.
Unable to find stress log via DAC
Unable to get AppDomain %lx
Unable to get AppDomain %p
Unable to get AppDomain information
Unable to get appdomain store
Unable to get array of AppDomains
Unable to get array of Assemblies
Unable to get array of Assemblies for the given AppDomain..
Unable to get array of JIT Managers
Unable to get code heap info
Unable to get codeHeader information
Unable to get IMetaDataImport for module %p
Unable to get information for %s.
Unable to get JIT info
Unable to get method name for MethodDesc %p
Unable to get module
Unable to get shared domain info
Unable to get symbol path length. IDebugSymbols3::GetSymbolPathWide HRESULT=0x%x.
Unable to get symbol path. IDebugSymbols3::GetSymbolPathWide HRESULT=0x%x.
Unable to get system domain info.
Unable to get the array of all AppDomains.
Unable to open file
Unable to parse line number
Unable to print IL for DynamicMethodDesc %p
Unable to query IDebugSymbol3 HRESULT=0x%x.
Unable to read module %p
Unable to set breakpoint with IDebugControl::Execute: %x
Unable to walk the managed stack. The current thread is likely not a 
Unable to write heap report
unaligned.
unbox
unbox.any
Undefined
understand xml format:
Unexpected special code %04X
UnhandledExceptionFilter
unknown
Unknown
UNKNOWN
Unknown exception
Unknown handle type '%s'.
Unknown internal frame.
unknown Jit
Unknown Jit encountered, ignored
UNKNOWN METHODDESC
Unknown MethodDesc (Module %s, mdToken %08x)
Unknown Module
Unknown option: %s
unknown type
UNLOAD_REQUESTED
Unmanaged code
Unmanaged to Managed transition
UnmapViewOfFile
unordered_map/set too long
Unrooted objects:                                           Percentage
Unsafe minidump commands are %s.
UNSET
unsigned int
unsigned long
unsigned short
Unstarted
UnstartedThread:
Unsupported platform
Unsupported token type
Untracked:
unused
uO8^Xt/
u-PWWS
UQPXY]Y[
ur-pk
ur-PK
URPQQh
Usage: !bpmd [-nofuturemodule] <module name> <managed function name> [<il offset>]
Usage: !bpmd <filename>:<line number>
Usage: !bpmd -clear <pending breakpoint number>
Usage: !bpmd -clearall
Usage: !bpmd -list
Usage: !bpmd -md <MethodDesc pointer>
Usage: !DumpVC <Method Table> <Value object start addr>
Usage: !ListNearObj <obj_address>
Usage: !Name2EE module_name item_name
Usage: !Token2EE module_name mdToken
Usage: DumpModule [-mt] <Module Address>
usage: HeapTraverse [-xml] filename
Usage: SaveModule <address> <file to save>
usage: StopOnException [-derived] [-create | -create2] <type name>
Use !PrintException %p to see more.
Use <exec cmd="!PrintException /d %p">!PrintException %p</exec> to see more.
use an asterisk on the left of the !, but the type on the right side needs
use pseudo-register $t1.
useful when you are debugging parts of the runtime which returns a raw PCCOR_SIGNATURE
User   CPU time   : %d days %02d:%02d:%02d.%02d
User interrupt.
user specfied compact LOH
User Suspend Pending
user32
Using !DumpSigElem we can find the type of the field by adding the offset of it (1) to 
using an Object Pointer from the output of !DumpStackObjects:
using mark list
UTF-16LEUNICODE
UTF-8
uz-UZ-Cyrl
uz-uz-cyrl
uz-uz-latn
uz-UZ-Latn
v$QSP
v(h8F
v0h(F
v2!L.2
v4RPQ
Value
value of all static fields.
VALUEARRAY
ValueClass
VALUETYPE
valuetype 
VAR OR ARG %d
Varargs: %u
VarFileInfo
Variable
Variable Handles:
vd;Pprt;
vector too long
-verify
Verify that 1) you have a recent build of the debugger (6.2.14 or newer)
VerifyHeap
Verifyheap
verifyheap
VerifyObj
verifyobj
VerifyStackTrace
VerQueryValueA
version of sos.dll (typing .load <full path to sos.dll> rather than using the
VERSION.dll
very high memory load and frag
vhRPQ
view and expand arrays and fields for managed variables. If a stack frame number is 
viewing the complete call stack when "kb" gets confused. For best results,
Virtual Call Stub Heap:
Virtual Memory    %8d     %8d
VirtualSize:    %8d KB       PeakVirtualSize:    %8d KB
vi-vn
vi-VN
vmmap
VMMap
VMStat
vmstat
vnffy
volatile.
VPh0%
VS_VERSION_INFO
Vtable Slots:    %x
VVh80
VVhX0
VVVVV
W8^.u:
W8^0u:
Wait 
wait until your managed program is running in order to use these commands. If 
WaitForSingleObjectEx
WakeAllConditionVariable
Walking heap...
Warmup
Warning: These roots are from finalizable objects that are not yet ready for finalization.
Washington1
Wasted: 0x00001000 bytes.
Watson Bucket parameters:
WatsonBuckets
we are at the initialization or shutdown of the gc heap. Commands related to 
We can do something similar for fields.  Here is the full signature of a field:
We can look at the individual elements of this object by adding the offsets into the 
we don't support allocating objects larger than 2GB on CLR v2.0 or prior. And this
We have taken a return address into Mainy.Main, and discovered information 
weak long
Weak Long Handles:
weak short
Weak Short Handles:
Weak WinRT Handles:
WeakLong
WeakShort
WeakWinRT
Wednesday
well as memory usage statistics.
What else can you do with an object? You might run !GCRoot, to determine what 
When called with no parameters, !DumpDomain will list all the AppDomains in the
When called without arguments, !SyncBlk will print the list of SyncBlocks 
When called without options, the output is first a list of objects in the heap,
when calling !DumpSigElem:
When creating a minidump without full memory, special functions are called at
When the argument lies in the managed heap, but is not a valid *object* address 
When the condition is not satisfied:
when you do this kind of memory analysis it could an aftereffect and doesn't 
When you see methods with the name "[Frame:...", that indicates a transition 
Where are we getting these module names from? Run !DumpDomain to see a list of
where N is 0, 1, 2, or "any". OR
which are exposed to managed code.  This is exposed to managed code through the
which can be specified using the -ccw option. 
While running ObjSize with no arguments may point to specific roots that hold 
WideCharToMultiByte
will be in PreEmptive GC mode. 
will be released the next time a cleanup occurs.
will get an error message when running any other commands. A full memory dump
will provide more details about the CLR, including where clr.dll is 
will replace older ones on threads which have reached their buffer limit.
will show attributes, as well as list the fields of the type. The output is 
Windows Debugger provide a command to make it easy to load the right copy of 
wIPS3
with annotations that convert metadata tokens to names.
With no parameters, !ObjSize lists the size of all objects found on managed 
Wj0XPV
work properly. !dumpheap and !verifyheap may incorrectly complain of heap 
Work Request in Queue: %d
Worker Thread:
WorkingSetSize: %8d KB       PeakWorkingSetSize: %8d KB
Workstation mode
would need to reissue the command.
would use this command. The output of this command contains all entries that 
WqVNHE
wrapper, the context, and the thread of the object.
WriteConsoleW
WriteFile
Writing %s format to file %s
Writing to file: %s
wrong argument
Wrong option: %s
wrong option: %s
Wrong option: stack selection wrong
WSVPP
WVQhPM
WWhX0
WWWPWS
x);OHu
X0V0T
xh-za
xh-ZA
xpxxxx
xSu$W
Xu*f;
xwpwpp
XXXX 
y#'>K
Y_[^]
Y__^[
y4RCC
y5h`9
Yes.  SOS respects the .prefer_dml option in the debugger.  If this setting is
Yield Requested
YoJ1E
You can also obtain this information with the !EHInfo command.
You can also pass a stack range to limit the output. Use the debugger 
You can also run the debugger command .cordll to control the debugger's
You can break into your process, load SOS, take a snapshot of your heap with 
You can download the CLR Profiler from this link:
You can find out more about the AppDomain with the !DumpDomain command. Not 
You can get a Module address from !DumpDomain, !DumpAssembly and other 
You can get an EEClass to look at from !DumpMT, !DumpObj, !Name2EE, and 
You can pass "*" for <module name> to find what that token maps to in every
you can see that thread 3 is attempting to acquire the Resource 00a7a1a4, which
You can specify breakpoints by file and line number if:
You can use "!DumpHeap -thinlock" to list objects locked in this way.
You can use it in four ways: 
You could run !DumpObj on any of those pointers to learn more. In this example,
you get the notation "(nested exceptions)", you can get details on those
you have just started the program a good way to do this is to type 
You might find an object pointer by running !DumpStackObjects and choosing
you should use !DumpSig to look at individual signature objects, but if you find a 
you the parameters and/or locals for that frame, and will also show you the fields 
you would print this output out and read it alongside a disassembly of the 
your application. 
Your version of the runtime/DAC do not support this command.
yxxx+
zh-chs
zh-CHS
zh-cht
zh-CHT
zh-cn
zh-CN
zh-HK
zh-hk
zh-mo
zh-MO
zh-sg
zh-SG
zh-tw
zh-TW
zu-za
zu-ZA
